/*
 * CORE_input.h: A single-file library for working with keyboards, pointing 
 * devices and gamepads using RawInput and XInput. One thread pushes input and 
 * device events into the input system as they occur. For each application tick,
 * an input event snapshot is acquired and treated as read-only for the duration
 * of the tick. Once the tick completes, the input event snapshot is returned 
 * to the input system.
 *
 * This software is dual-licensed to the public domain and under the following 
 * license: You are hereby granted a perpetual, irrevocable license to copy, 
 * modify, publish and distribute this file as you see fit.
 *
 */
#ifndef __CORE_INPUT_H__
#define __CORE_INPUT_H__

/* #define CORE_STATIC to make all function declarations and definitions static.     */
/* This is useful if the library needs to be included multiple times in the project. */
#ifdef  CORE_STATIC
#define CORE_API(_rt)                     static _rt
#else
#define CORE_API(_rt)                     extern _rt
#endif

/* @summary Define the value indicating an unused device handle.
 */
#ifndef CORE_INPUT_DEVICE_HANDLE_NONE
#define CORE_INPUT_DEVICE_HANDLE_NONE     INVALID_HANDLE_VALUE
#endif

/* @summary Define the maximum number of input devices of each type.
 */
#ifndef CORE_INPUT_MAX_DEVICES_PER_TYPE
#define CORE_INPUT_MAX_DEVICES_PER_TYPE   4
#endif

/* @summary Define the maximum number of keys that can be reported as down, pressed or released in a single update.
 */
#ifndef CORE_INPUT_MAX_KEYS
#define CORE_INPUT_MAX_KEYS               256
#endif

/* @summary Define the maximum number of buttons that can be reported as down, pressed or released in a single update.
 */
#ifndef CORE_INPUT_MAX_BUTTONS
#define CORE_INPUT_MAX_BUTTONS            32 
#endif

/* @summary Define a bitvector used to poll all possible gamepad ports (all bits set.)
 */
#ifndef CORE_INPUT_ALL_GAMEPAD_PORTS
#define CORE_INPUT_ALL_GAMEPAD_PORTS      ~((uint32_t)(0))
#endif

/* @summary Define the value indicating that an input packet was dropped because too many devices of the specified type are attached.
 */
#ifndef CORE_INPUT_DEVICE_TOO_MANY
#define CORE_INPUT_DEVICE_TOO_MANY        ~((uint32_t)(0))
#endif

/* @summary Define the value indicating that a device was not found in the specified device list.
 */
#ifndef CORE_INPUT_DEVICE_NOT_FOUND
#define CORE_INPUT_DEVICE_NOT_FOUND       ~((uint32_t)(0))
#endif

/* @summary Retrieve the alignment of a particular type, in bytes.
 * @param _type A typename, such as int, specifying the type whose alignment is to be retrieved.
 */
#ifndef CORE_AlignOf
#define CORE_AlignOf(_type)                                                    \
    __alignof(_type)
#endif

/* @summary Align a non-zero size up to the nearest even multiple of a given power-of-two.
 * @param _quantity is the size value to align up.
 * @param _alignment is the desired power-of-two alignment.
 t wi*/
#ifndef CORE_AlignUp
#define CORE_AlignUp(_quantity, _alignment)                                    \
    (((_quantity) + ((_alignment)-1)) & ~((_alignment)-1))
#endif

/* @summary For a given address, return the address aligned for a particular type.
 * @param _address The unaligned address.
 * @param _type A typename, such as int, specifying the type whose alignment is to be retrieved.
 */
#ifndef CORE_AlignFor
#define CORE_AlignFor(_address, _type)                                         \
    ((void*)(((uint8_t*)(_address)) + ((((__alignof(_type))-1)) & ~((__alignof(_type))-1))))
#endif

/* Forward-declare types exported by the library */
struct _CORE_INPUT_EVENTS;
struct _CORE_INPUT_POINTER_EVENTS;
struct _CORE_INPUT_GAMEPAD_EVENTS;
struct _CORE_INPUT_KEYBOARD_EVENTS;
struct _CORE_INPUT_SYSTEM;
struct _CORE_INPUT_SYSTEM_INIT;

/* @summary Define the data used to report events generated by a single XInput gamepad device between two state snapshots.
 */
typedef struct _CORE_INPUT_GAMEPAD_EVENTS {
    float                         LeftTrigger;            /* The left trigger value, in [0, 255]. */
    float                         RightTrigger;           /* The right trigger value, in [0, 255]. */
    float                         LeftStick[2];           /* The left analog stick normalized X and Y. */
    float                         LeftStickMagnitude;     /* The magnitude of the left stick vector. */
    float                         RightStick[2];          /* The right analog stick normalized X and Y. */
    float                         RightStickMagnitude;    /* The magnitude of the right stick vector. */
    uint32_t                      MaxButtonEvents;        /* The maximum number of button events that can be reported. This defines the dimension of the ButtonsDown/ButtonsPressed/ButtonsReleased arrays. */
    uint32_t                      ButtonDownCount;        /* The number of buttons currently in the pressed state. This defines the number of valid entries in the ButtonsDown array. */
    uint32_t                      ButtonPressedCount;     /* The number of buttons just pressed. This defines the number of valid entries in the ButtonsPressed array. */
    uint32_t                      ButtonReleasedCount;    /* The number of buttons just released. This defines the number of valid entries in the ButtonsReleased array. */
    uint16_t                     *ButtonsDown;            /* The XINPUT_GAMEPAD_x identifiers for all buttons currently in the pressed state. */
    uint16_t                     *ButtonsPressed;         /* The XINPUT_GAMEPAD_x identifiers for all buttons that were just transitioned to the pressed state. */
    uint16_t                     *ButtonsReleased;        /* The XINPUT_GAMEPAD_x identifiers for all buttons that were just transitioned to the released state. */
} CORE_INPUT_GAMEPAD_EVENTS;

/* @summary Define the data used to report input events generated by a pointer device (mouse, trackpad, touchscreen, pen, etc.) between two state snapshots.
 */
typedef struct _CORE_INPUT_POINTER_EVENTS
{
    int32_t                       Cursor[2];              /* The absolute cursor position in virtual display space. */
    int32_t                       Mickeys[2];             /* The relative movement of the pointer from the last update, in device-specific units. */
    int32_t                       WheelDelta;             /* The mouse wheel delta from the last update. */
    uint32_t                      MaxButtonEvents;        /* The maximum number of button events that can be reported. This defines the dimension of the ButtonsDown/ButtonsPressed/ButtonsReleased arrays. */
    uint32_t                      ButtonDownCount;        /* The number of buttons currently in the pressed state. This defines the number of valid entries in the ButtonsDown array. */
    uint32_t                      ButtonPressedCount;     /* The number of buttons just pressed. This defines the number of valid entries in the ButtonsPressed array. */
    uint32_t                      ButtonReleasedCount;    /* The number of buttons just released. This defines the number of valid entries in the ButtonsReleased array. */
    uint16_t                     *ButtonsDown;            /* The MK_nBUTTON identifiers for all buttons currently in the pressed state. */
    uint16_t                     *ButtonsPressed;         /* The MK_nBUTTON identifiers for all buttons that were just transitioned to the pressed state. */
    uint16_t                     *ButtonsReleased;        /* The MK_nBUTTON identifiers for all buttons that were just transitioned to the released state. */
} CORE_INPUT_POINTER_EVENTS;

/* @summary Define the data used to report keyboard events generated by a keyboard device between two state snapshots.
 */
typedef struct _CORE_INPUT_KEYBOARD_EVENTS {
    uint32_t                      MaxKeyEvents;           /* The maximum number of key events that can be reported. This defines the dimansion of the KeysDown/KeysPressed/KeysReleased arrays. */
    uint32_t                      KeyDownCount;           /* The number of keys currently in the pressed state. This defines the number of valid entries in the KeysDown array. */
    uint32_t                      KeyPressedCount;        /* The number of keys just pressed. This defines the number of valid entries in the KeysPressed array. */
    uint32_t                      KeyReleasedCount;       /* The number of keys just released. This defines the number of valid entries in the KeysReleased array. */
    uint8_t                      *KeysDown;               /* The VK_x virtual key code for all keys currently in the pressed state. */
    uint8_t                      *KeysPressed;            /* The VK_x virtual key code for all keys that were just transitioned to the pressed state. */
    uint8_t                      *KeysReleased;           /* The VK_x virtual key code for all keys that were just transitioned to the released state. */
} CORE_INPUT_KEYBOARD_EVENTS;

/* @summary Define the data associated with a snapshot of input device events representing all input system events that have occurred since the last poll.
 * This structure should be treated as read-only by the application.
 */
typedef struct _CORE_INPUT_EVENTS {
    struct _CORE_INPUT_SYSTEM    *InputSystem;            /* The _CORE_INPUT_SYSTEM that owns the input event buffer. */
    struct _CORE_INPUT_EVENTS    *NextEvents;             /* A pointer to the next item in the queue. User code always sees this value as NULL. */
    uint64_t                      StartTime;              /* The timestamp, in nanoseconds, at which the input event interval began. */
    uint64_t                      CaptureTime;            /* The timestamp, in nanoseconds, at which the input events were retrieved by the application. */
    uint32_t                      MaxGamepadDevices;      /* The maximum number of gamepad devices that can be attached to the system. This value defines the dimensions of the GamepadAttachList/GamepadRemoveList/GamepadDeviceIds/GamepadDeviceEvents arrays. */
    uint32_t                      GamepadAttachCount;     /* The number of gamepad devices that were attached to the system since the last poll. This value defines the number of valid entries in the GamepadAttachList array. */
    uint32_t                      GamepadRemoveCount;     /* The number of gamepad devices that were detached from the system since the last poll. This value defines the number of valid entries in the GamepadRemoveList array. */
    uint32_t                      GamepadDeviceCount;     /* The number of gamepad devices that are currently attached to the system. This value defines the number of valid entries in the GamepadDeviceIds and GamepadDeviceEvents arrays. */
    DWORD                        *GamepadDeviceIds;       /* An array of GamepadDeviceCount entries specifying the port numbers to which active gamepads are attached. */
    CORE_INPUT_GAMEPAD_EVENTS    *GamepadDeviceEvents;    /* An array of GamepadDeviceCount entries specifying the input events that have occurred for each attached gamepad device. */
    DWORD                        *GamepadAttachList;      /* An array of GamepadAttachCount entries specifying the port IDs to which gamepad devices were attached since the last poll. */
    DWORD                        *GamepadRemoveList;      /* An array of GamepadRemoveCount entries specifying the port IDs from which gamepad devices were removed since the last poll.*/
    uint32_t                      MaxPointerDevices;      /* The maximum number of pointer devices that can be attached to the system. This value defines the dimensions of the PointerAttachList/PointerRemoveList/PointerDeviceIds/PointerDeviceEvents arrays. */
    uint32_t                      PointerAttachCount;     /* The number of pointer devices that were attached to the system since the last poll. This value defines the number of valid entries in the PointerAttachList array. */
    uint32_t                      PointerRemoveCount;     /* The number of pointer devices that were detached from the system since the last poll. This value defines the number of valid entries in the PointerRemoveList array. */
    uint32_t                      PointerDeviceCount;     /* The number of pointer devices that are currently attached to the system. This value defines the number of valid entries in the PointerDeviceIds and PointerDeviceEvents arrays. */
    HANDLE                       *PointerDeviceIds;       /* An array of PointerDeviceCount handles specifying unique identifiers for each pointer device attached to the system. */
    CORE_INPUT_POINTER_EVENTS    *PointerDeviceEvents;    /* An array of PointerDeviceCount entries specifying the input events that have occurred since the last poll for each pointer device. */
    HANDLE                       *PointerAttachList;      /* An array of PointerAttachCount entries specifying the device identifiers for each pointer device attached to the system since the last poll. */
    HANDLE                       *PointerRemoveList;      /* An array of PointerRemoveCount entries specifying the device identifiers for each pointer device detached from the system since the last poll. */
    uint32_t                      MaxKeyboardDevices;     /* The maximum number of keyboard devices that can be attached to the system. This value defines the dimensions of the KeyboardAttachList/KeyboardRemoveList/KeyboardDeviceIds/KeyboardDeviceEvents arrays. */
    uint32_t                      KeyboardAttachCount;    /* The number of keyboard devices that were attached to the system since the last poll. This value defines the number of valid entries in the KeyboardAttachList array. */
    uint32_t                      KeyboardRemoveCount;    /* The number of keyboard devices that were removed from the system since the last poll. This value defines the number of valid entries in the KeyboardRemoveList array. */
    uint32_t                      KeyboardDeviceCount;    /* The number of keyboard devices that are currently attached to the system. This value defines the number of valid entires in the KeyboardDeviceIds and KeyboardDeviceEvents arrays. */
    HANDLE                       *KeyboardDeviceIds;      /* An array of KeyboardDeviceCount entries specifying unique device identifiers for each keyboard device attached to the system. */
    CORE_INPUT_KEYBOARD_EVENTS   *KeyboardDeviceEvents;   /* An array of KeyboardDeviceCount entries specifying the input events that have occurred since the last poll for each keyboard device. */
    HANDLE                       *KeyboardAttachList;     /* An array of KeyboardAttachCount entries specifying the device identifier for each keyboard device attached to the system since the last poll. */
    HANDLE                       *KeyboardRemoveList;     /* An array of KeyboardRemoveCount entries specifying the device identifier for each keyboard device removed from the system since the last poll. */
} CORE_INPUT_EVENTS;

/* @summary Define the data used to configure the behavior of the input system.
 */
typedef struct _CORE_INPUT_SYSTEM_INIT {
    uint32_t                      MaxPointerDevices;      /* The maximum number of supported pointer devices attached to the system at any one time. */
    uint32_t                      MaxGamepadDevices;      /* The maximum number of supported gamepad devices attached to the system at any one time. */
    uint32_t                      MaxKeyboardDevices;     /* The maximum number of supported keyboard devices attached to the system at any one time. */
    uint32_t                      MaxEventsPerGamepad;    /* The maximum number of button events that should be reported per gamepad device. */
    uint32_t                      MaxEventsPerPointer;    /* The maximum number of button events that should be reported per pointer device. */
    uint32_t                      MaxEventsPerKeyboard;   /* The maximum number of key events that should be reported per keyboard device. */
    uint32_t                      MaxInputEventsInFlight; /* The maximum number of _CORE_INPUT_EVENTS structures expected to be in use at any one time. */
    HWND                          SourceWindow;           /* The handle of the window from which the input system receives input events. */
    void                         *MemoryStart;            /* The start of the memory block providing storage for the input system. */
    uint64_t                      MemorySize;             /* The size of the memory block providing storage for the input system, in bytes. */
} CORE_INPUT_SYSTEM_INIT;

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* @summary Given a RawInput keyboard packet, retrieve the virtual key code and scan code values.
 * @param vkey_code On return, stores the virtual key code identifier (VK_x). This value is always less than or equal to 255.
 * @param scan_code On return, stores the scan code value, suitable for passing to CORE_InputCopyKeyDisplayName.
 * @param key The RawInput keyboard packet to process.
 * @return Non-zero if the virtual key code and scan code were extracted, or zero if the packet was part of an escape sequence.
 */
CORE_API(int)
CORE_InputGetVirtualKeyAndScanCode
(
    uint32_t    *vkey_code, 
    uint32_t    *scan_code,
    RAWKEYBOARD const *key 
);

/* @summary Retrieve a localized string suitable for use as a display name for a given virtual key code.
 * @param buffer The caller-managed buffer to receive the string.
 * @param buffer_max_chars The maximum number of characters that can be written to the buffer, including the terminating nul.
 * @param vkey_code The virtual key code (VK_x) for the key whose name should be retrieved.
 * @return The number of characters written to the buffer, not including the terminating nul.
 */
CORE_API(size_t)
CORE_InputCopyKeyDisplayName
(
    WCHAR           *buffer, 
    size_t buffer_max_chars, 
    uint32_t      vkey_code
);

/* @summary Determine the amount of memory required to initialize an input system with the given configuration.
 * The SourceWindow, MemoryStart and MemorySize fields of the INIT structure are not required to be set.
 * @param init Data specifying the configuration of the input system.
 * @return The minimum number of bytes required to successfully initialize an input system with the given attributes.
 */
CORE_API(size_t)
CORE_QueryInputSystemMemorySize
(
    CORE_INPUT_SYSTEM_INIT *init
);

/* @summary Initialize an input system object used to retrieve input events for a window.
 * @param input_system On return, this location is updated with a pointer to the created input system object.
 * @param init Data used to configure the input system.
 * @return Zero if the input system is successfully initialized, or -1 if an error occurred.
 */
CORE_API(int)
CORE_CreateInputSystem
(
    struct _CORE_INPUT_SYSTEM **input_system,
    CORE_INPUT_SYSTEM_INIT             *init
);

/* @summary Free resources associated with an input system object.
 * @param input_system The _CORE_INPUT_SYSTEM to destroy.
 */
CORE_API(void)
CORE_DeleteInputSystem
(
    struct _CORE_INPUT_SYSTEM *input_system
);

/* @summary Update the input device state based on a RawInput packet sent to the associated window.
 * @param input_system The _CORE_INPUT_SYSTEM to update.
 * @param input_packet The RawInput packet to process.
 */
CORE_API(void)
CORE_PushRawInputPacket
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    RAWINPUT                  *input_packet
);

/* @summary Update the input device state based on a RawInput device change notification sent to the associated window.
 * @param input_system The _CORE_INPUT_SYSTEM to update.
 * @param wparam The WPARAM sent to the window with the device change message.
 * @param lparam The LPARAM sent to the window with the device change message.
 */
CORE_API(void)
CORE_PushRawInputDeviceChange
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    WPARAM                           wparam, 
    LPARAM                           lparam
);

/* @summary Simulate a key press event.
 * @param input_system The _CORE_INPUT_SYSTEM to update.
 * @param device The handle of the target keyboard device.
 * @param vkcode One of the VK_x constants identifying the pressed key.
 */
CORE_API(void)
CORE_SimulateKeyPress
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    HANDLE                           device, 
    UINT                             vkcode
);

/* @summary Simulate a key release event.
 * @param input_system The _CORE_INPUT_SYSTEM to update.
 * @param device The handle of the target keyboard device.
 * @param vkcode One of the VK_x constants identifying the released key.
 */
CORE_API(void)
CORE_SimulateKeyRelease
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    HANDLE                           device, 
    UINT                             vkcode
);

/* @summary Retrieve a _CORE_INPUT_EVENTS structure specifying the input device events that have occurred since the prior poll.
 * The calling thread may block if the maximum number of input event buffers have been returned without being released.
 * @param input_system The _CORE_INPUT_SYSTEM to query.
 * @return An input event buffer specifying all of the input events that have occurred since the last consume operation.
 */
CORE_API(struct _CORE_INPUT_EVENTS*)
CORE_ConsumeInputEvents
(
    struct _CORE_INPUT_SYSTEM *input_system
);

/* @summary Return an input event buffer to the input system. This function may un-block a waiting thread.
 * @param event_buffer The _CORE_INPUT_EVENTS representing the event buffer being returned.
 */
CORE_API(void)
CORE_ReturnInputEvents
(
    struct _CORE_INPUT_EVENTS *event_buffer
);

#ifdef __cplusplus
}; /* extern "C" */
#endif /* __cplusplus */

#endif /* __CORE_INPUT_H__ */

#ifdef CORE_INPUT_IMPLEMENTATION

/* @summary For a given type, calculate the maximum number of bytes that will need to be allocated for an instance of that type, accounting for the padding required for proper alignment.
 * @param _type A typename, such as int, specifying the type whose allocation size is being queried.
 */
#ifndef CORE__InputAllocationSizeType
#define CORE__InputAllocationSizeType(_type)                                   \
    ((sizeof(_type)) + (__alignof(_type)-1))
#endif

/* @summary For a given type, calculate the maximum number of bytes that will need to be allocated for an array of instances of that type, accounting for the padding required for proper alignment.
 * @param _type A typename, such as int, specifying the type whose allocation size is being queried.
 * @param _count The number of elements in the array.
 */
#ifndef CORE__InputAllocationSizeArray
#define CORE__InputAllocationSizeArray(_type, _count)                          \
    ((sizeof(_type) * (_count)) + (__alignof(_type)-1))
#endif

/* @summary Allocate host memory with the correct size and alignment for an instance of a given type from a memory arena.
 * @param _arena The CORE__INPUT_ARENA from which the allocation is being made.
 * @param _type A typename, such as int, specifying the type being allocated.
 * @return A pointer to the start of the allocated memory block, or NULL.
 */
#ifndef CORE__InputMemoryArenaAllocateType
#define CORE__InputMemoryArenaAllocateType(_arena, _type)                      \
    ((_type*) CORE__InputMemoryArenaAllocateHost((_arena), sizeof(_type), __alignof(_type)))
#endif

/* @summary Allocate memory with the correct size and alignment for an array of instance of a given type from a memory arena.
 * @param _arena The CORE__INPUT_ARENA from which the allocation is being made.
 * @param _type A typename, such as int, specifying the type being allocated.
 * @param _count The number of elements in the array.
 * @return A pointer to the start of the allocated memory block, or NULL.
 */
#ifndef CORE__InputMemoryArenaAllocateArray
#define CORE__InputMemoryArenaAllocateArray(_arena, _type, _count)             \
    ((_type*) CORE__InputMemoryArenaAllocateHost((_arena), sizeof(_type) * (_count), __alignof(_type)))
#endif

/* @summary Resolve an entry point from a DLL at runtime. If the entry point is not available, set the function pointer to the stub implementation.
 * Some naming conventions are necessary for these macros to work. Given function name _name = SomeFunction:
 * The function pointer typedef should be: SomeFunction_Func
 * The dispatch table field should be    : SomeFunction
 * The stub function name should be      : CORE__SomeFunction_Stub
 * The resolve call should be            : CORE__InputResolveRuntimeFunction(dispatch_table, dll_instance, SomeFunction)
 * @param _disp A pointer to the structure representing the dispatch table.
 * @param _dll The HMODULE of the DLL returned by LoadLibrary.
 * @param _func_name The name of the function to resolve.
 */
#ifndef CORE__InputResolveRuntimeFunction
#define CORE__InputResolveRuntimeFunction(_disp, _dll, _func_name)             \
    do {                                                                       \
        _disp->_func_name=(_func_name##_Func)GetProcAddress(_dll,#_func_name); \
        if (_disp->_func_name == NULL) {                                       \
            _disp->_func_name  = CORE__##_func_name##_Stub;                    \
        }                                                                      \
    __pragma(warning(push));                                                   \
    __pragma(warning(disable:4127));                                           \
    } while (0);                                                               \
    __pragma(warning(pop))
#endif

/* @summary Implement a conditional check to determine whether a runtime function was resolved to its stub implementation.
 * @param _disp A pointer to the structure representing the dispatch table.
 * @param _func_name The name of the runtime function.
 */
#ifndef CORE__InputIsRuntimeFunctionMissing
#define CORE__InputIsRuntimeFunctionMissing(_disp, _func_name)                 \
    _disp->_func_name == CORE__##_func_name##_Stub
#endif

/* @summary Retrieve a pointer to the start of a device state record in a device list.
 * @param _list The CORE__INPUT_DEVICE_LIST to query.
 * @param _index The zero-based index of the device whose state will be returned.
 * @param _state_size The size of the device state record, in bytes.
 * @return A pointer to the start of the device state record for the specified device identified by index.
 */
#ifndef CORE__InputDeviceListState
#define CORE__InputDeviceListState(_list, _index , _state_size)                \
    (((uint8_t*)(_list)->DeviceState) + ((_index)*(_state_size)))
#endif

/* @summary Retrieve a the device state record for a gamepad device identified by index.
 * @param _list The CORE__INPUT_DEVICE_LIST to query.
 * @param _index The zero-based index of the gamepad device whose state will be retrieved.
 * @return The CORE__INPUT_GAMEPAD_STATE for the specified gamepad.
 */
#ifndef CORE__GamepadDeviceListState
#define CORE__GamepadDeviceListState(_list, _index)                            \
    (CORE__INPUT_GAMEPAD_STATE*) CORE__InputDeviceListState((_list), (_index), sizeof(CORE__INPUT_GAMEPAD_STATE))
#endif

/* @summary Retrieve a the device state record for a pointer device identified by index.
 * @param _list The CORE__INPUT_DEVICE_LIST to query.
 * @param _index The zero-based index of the pointer device whose state will be retrieved.
 * @return The CORE__INPUT_POINTER_STATE for the specified pointer.
 */
#ifndef CORE__PointerDeviceListState
#define CORE__PointerDeviceListState(_list, _index)                            \
    (CORE__INPUT_POINTER_STATE*) CORE__InputDeviceListState((_list), (_index), sizeof(CORE__INPUT_POINTER_STATE))
#endif

/* @summary Retrieve a the device state record for a keyboard device identified by index.
 * @param _list The CORE__INPUT_DEVICE_LIST to query.
 * @param _index The zero-based index of the keyboard device whose state will be retrieved.
 * @return The CORE__INPUT_KEYBOARD_STATE for the specified keyboard.
 */
#ifndef CORE__KeyboardDeviceListState
#define CORE__KeyboardDeviceListState(_list, _index)                           \
    (CORE__INPUT_KEYBOARD_STATE*)CORE__InputDeviceListState((_list), (_index), sizeof(CORE__INPUT_KEYBOARD_STATE))
#endif

/* @summary Define the data associated with an internal memory arena allocator.
 */
typedef struct _CORE__INPUT_ARENA {
    uint8_t                         *BaseAddress;                 /* The base address of the memory range. */
    size_t                           MemorySize;                  /* The size of the memory block, in bytes. */
    size_t                           NextOffset;                  /* The offset of the next available address. */
} CORE__INPUT_ARENA;

/* @summary Define the state data associated with a single XInput gamepad device.
 */
typedef struct _CORE__INPUT_GAMEPAD_STATE {
    uint32_t                         LTrigger;                    /* The left trigger value, in [0, 255]. */
    uint32_t                         RTrigger;                    /* The right trigger value, in [0, 255]. */
    uint32_t                         Buttons;                     /* A bit vector storing up to 32 button states, where a set bit indicates that the button is down. */
    float                            LStick[4];                   /* The left analog stick X, Y, magnitude and normalized magnitude. */
    float                            RStick[4];                   /* The right analog stick X, Y, magnitude and normalized magnitude. */
} CORE__INPUT_GAMEPAD_STATE;

/* @summary Statically-initialize a _CORE__INPUT_GAMEPAD_STATE structure.
 */
#ifndef CORE__INPUT_GAMEPAD_STATE_STATIC_INIT
#define CORE__INPUT_GAMEPAD_STATE_STATIC_INIT                                  \
    {                                                                          \
          0,            /* LTrigger */                                         \
          0,            /* RTrigger */                                         \
          0,            /* Buttons */                                          \
        { 0, 0, 0, 0 }, /* LStick[X,Y,M,N] */                                  \
        { 0, 0, 0, 0 }  /* RStick[X,Y,M,N] */                                  \
    }
#endif

/* @summary Define the state data associated with a single RawInput pointer device.
 */
typedef struct _CORE__INPUT_POINTER_STATE {
    int32_t                          Pointer[2];                  /* The absolute X and Y coordinates of the pointer, in virtual display space. */
    int32_t                          Relative[3];                 /* The high definition relative X, Y and Z (wheel) values. The X and Y are specified in mickeys. */ 
    uint32_t                         Buttons;                     /* A bit vector storing up to 32 button states, where a set bit indicates that the button is down. */
    uint32_t                         Flags;                       /* Bitflags indicating that postprocessing needs to be performed. */
} CORE__INPUT_POINTER_STATE;

/* @summary Statically-initialize a _CORE__INPUT_POINTER_STATE structure.
 */
#ifndef CORE__INPUT_POINTER_STATE_STATIC_INIT
#define CORE__INPUT_POINTER_STATE_STATIC_INIT                                  \
    {                                                                          \
        { 0, 0    }, /* Pointer[X,Y] */                                        \
        { 0, 0, 0 }, /* Relative[X,Y,Z] */                                     \
          0,         /* Buttons */                                             \
          0          /* Flags */                                               \
    }
#endif

/* @summary Define the state data associated with a single RawInput keyboard device.
 */
typedef struct _CORE__INPUT_KEYBOARD_STATE {
    uint32_t                         KeyState[8];                 /* A bitvector (256 bits) mapping scan code to key state, where a set bit indicates that the key is down. */
} CORE__INPUT_KEYBOARD_STATE;

/* @summary Statically-initialize a _CORE__INPUT_KEYBOARD_STATE structure.
 */
#ifndef CORE__INPUT_KEYBOARD_STATE_STATIC_INIT
#define CORE__INPUT_KEYBOARD_STATE_STATIC_INIT                                 \
    {                                                                          \
        { 0, 0, 0, 0, 0, 0, 0, 0 } /* KeyState */                              \
    }
#endif

/* @summary Define the data associated with a list of input devices of a particular type.
 */
typedef struct _CORE__INPUT_DEVICE_LIST {
    uint32_t                         MaxDevices;                  /* The maximum number of device records that can be stored in the list. This value defines the dimension of the DeviceHandle and DeviceState arrays. */
    uint32_t                         DeviceCount;                 /* The number of valid device records in the list. This value defines the number of valid values in the DeviceHandle and DeviceState arrays. */
    HANDLE                          *DeviceHandle;                /* An array of MaxDevices device handles, of which DeviceCount are valid, specifying unique identifiers for each input device in the list. */
    void                            *DeviceState;                 /* An array of MaxDevices structures, of which DeviceCount are valid. The structure type is one of _CORE__INPUT_GAMEPAD_STATE, _CORE__INPUT_POINTER_STATE or _CORE__INPUT_KEYBOARD_STATE. All instances have the same type. */
} CORE__INPUT_DEVICE_LIST;

/* @summary Define the data associated with a RawInput device membership set computed from two device list snapshots.
 * The maximum number of entries in the set is 2 * the maximum number of devices per-type, because (theoretically) the device list snapshots could have a completely different set of devices.
 */
typedef struct _CORE__INPUT_DEVICE_SET {
    #define MAX_DEVICES             (CORE_INPUT_MAX_DEVICES_PER_TYPE*2)
    uint32_t                         MaxDevices;                  /* The maximum number of device records in the set. This value defines the dimension of the DeviceIds/Membership/PrevIndex/CurrIndex arrays. */
    uint32_t                         DeviceCount;                 /* The number of valid device records in the set. This value defines the number of valid entries in the DeviceIds, Membership, PrevIndex and CurrIndex arrays. */
    HANDLE                           DeviceIds [MAX_DEVICES];     /* An array of MaxDevices device handles, of which DeviceCount are valid, uniquely identifying the devices in the set. */
    uint32_t                         Membership[MAX_DEVICES];     /* An array of MaxDevices _CORE__INPUT_DEVICE_SET_MEMBERSHIP bit flags, of which DeviceCount are valid, specifying the membership for each device in the set. */
    uint8_t                          PrevIndex [MAX_DEVICES];     /* An array of MaxDevices index values, of which DeviceCount are valid, specifying the index of the device in the previous device list. */
    uint8_t                          CurrIndex [MAX_DEVICES];     /* An array of MaxDevices index values, of which DeviceCount are valid, specifying the index of the device in the current device list. */
    #undef  MAX_DEVICES
} CORE__INPUT_DEVICE_SET;

/* @summary Define the function pointer types for the entry points loaded from the XInput module on the host system.
 * See XInput.h (distributed with the Windows SDK) for details.
 */
typedef void  (WINAPI *XInputEnable_Func               )(BOOL);
typedef DWORD (WINAPI *XInputGetState_Func             )(DWORD, struct _XINPUT_STATE*);
typedef DWORD (WINAPI *XInputSetState_Func             )(DWORD, struct _XINPUT_VIBRATION*);
typedef DWORD (WINAPI *XInputGetKeystroke_Func         )(DWORD, DWORD, struct _XINPUT_KEYSTROKE*);
typedef DWORD (WINAPI *XInputGetCapabilities_Func      )(DWORD, DWORD, struct _XINPUT_CAPABILITIES*);
typedef DWORD (WINAPI *XInputGetBatteryInformation_Func)(DWORD, BYTE, struct _XINPUT_BATTERY_INFORMATION*);
typedef DWORD (WINAPI *XInputGetAudioDeviceIds_Func    )(DWORD, LPWSTR, UINT*, LPWSTR, UINT*);

/* @summary Define the table of function pointers to the dynamically-loaded XInput APIs.
 */
typedef struct _CORE__INPUT_XINPUT_DISPATCH {
    HMODULE                          XInputModule;                /* The module handle of the loaded XInput component. */
    XInputEnable_Func                XInputEnable;                /* The pointer to the XInputEnable function. */
    XInputGetState_Func              XInputGetState;              /* The pointer to the XInputGetState function. */
    XInputSetState_Func              XInputSetState;              /* The pointer to the XInputSetState function. */
    XInputGetKeystroke_Func          XInputGetKeystroke;          /* The pointer to the XInputGetKeystroke function. */
    XInputGetCapabilities_Func       XInputGetCapabilities;       /* The pointer to the XInputGetCapabilities function. */
    XInputGetBatteryInformation_Func XInputGetBatteryInformation; /* The pointer to the XInputGetBatteryInformation function. */
    XInputGetAudioDeviceIds_Func     XInputGetAudioDeviceIds;     /* The pointer to the XInputGetAudioDeviceIds function. */
} CORE__INPUT_XINPUT_DISPATCH;

/* @summary Define the data associated with an input system. An input system manages the user input associated with a single window.
 */
typedef struct _CORE_INPUT_SYSTEM {
    HANDLE                           QueueSemaphore;              /* A semaphore object used to sleep a thread attempting to acquire an input event snapshot. */
    CORE_INPUT_EVENTS              **InputEventsQueue;            /* A fixed-size array of pointers to CORE_INPUT_EVENTS from which threads acquire an input event snapshot. */
    uint32_t                         InputEventsCount;            /* The number of CORE_INPUT_EVENTS structures allocated within the system and representing the maximum number of in-flight snapshots. */
    uint32_t                         QueueHead;                   /* The queue index of the next available item in input events queue. */
    uint32_t                         WriteIndex;                  /* The array index of the buffer to which input state is written. This value is either 0 or 1. */
    CRITICAL_SECTION                 WriterLock;                  /* Lock used to synchronize a thread pushing input data with a thread acquiring an input event snapshot. */
    uint32_t                         GamepadPorts[2];             /* A bit vector where a bit is set if a gamepad port was connected. WriteIndex accesses the data for the current tick. */
    CORE__INPUT_DEVICE_LIST          GamepadDeviceList[2];        /* The list of gamepad devices seen on the current and previous tick. WriteIndex accesses the data for the current tick. */
    CORE__INPUT_DEVICE_LIST          PointerDeviceList[2];        /* The list of pointer devices seen on the current and previous tick. WriteIndex accesses the data for the current tick. */
    CORE__INPUT_DEVICE_LIST          KeyboardDeviceList[2];       /* The list of keyboard devices seen on the current and previous tick. WriteIndex accesses the data for the current tick. */
    CORE__INPUT_XINPUT_DISPATCH      XInput;                      /* The XInput API dispatch table used for polling gamepad state. */
    CRITICAL_SECTION                 ReturnLock;                  /* Lock used to synchronize multiple threads concurrently returning input event buffers. */
    uint32_t                         QueueTail;                   /* The queue index of the next return slot in the input events queue. */
    CORE_INPUT_EVENTS              **InputEvents;                 /* Storage for the set of CORE_INPUT_EVENTS managed by the input system. */
    void                            *MemoryStart;                 /* The start of the memory block providing storage for the input system. */
    uint64_t                         MemorySize;                  /* The size of the memory block providing storage for the input system, in bytes. */
    HWND                             SourceWindow;                /* The handle of the window from which the input system receives data. */
} CORE__INPUT_SYSTEM;

typedef enum _CORE__INPUT_DEVICE_SET_MEMBERSHIP {
    CORE__INPUT_DEVICE_SET_MEMBERSHIP_NONE = (0UL << 0),          /* The device is not present in the previous or the current list. */
    CORE__INPUT_DEVICE_SET_MEMBERSHIP_PREV = (1UL << 0),          /* The device is present in the previous device list. */
    CORE__INPUT_DEVICE_SET_MEMBERSHIP_CURR = (1UL << 1),          /* The device is present in the current device list. */
} CORE__INPUT_DEVICE_SET_MEMBERSHIP;

typedef enum _CORE__INPUT_POINTER_FLAGS {
    CORE__INPUT_POINTER_FLAGS_NONE         = (0UL << 0),          /* No post-processing is required. */
    CORE__INPUT_POINTER_FLAG_ABSOLUTE      = (1UL << 0),          /* The device only specifies absolute positioning. */
} CORE__INPUT_POINTER_FLAGS;

/* @summary Initialize a memory arena allocator around an externally-managed memory block.
 * @param arena The memory arena allocator to initialize.
 * @param memory A pointer to the start of the memory block to sub-allocate from.
 * @param memory_size The size of the memory block, in bytes.
 */
static void
CORE__InputInitMemoryArena
(
    CORE__INPUT_ARENA *arena, 
    void             *memory,
    size_t       memory_size
)
{
    arena->BaseAddress =(uint8_t*) memory;
    arena->MemorySize  = memory_size;
    arena->NextOffset  = 0;
}

/* @summary Sub-allocate memory from an arena.
 * @param arena The memory arena from which the memory will be allocated.
 * @param size The minimum number of bytes to allocate.
 * @param alignment The required alignment of the returned address, in bytes. This value must be zero, or a power-of-two.
 * @return A pointer to the start of a memory block of at least size bytes, or NULL.
 */
static void*
CORE__InputMemoryArenaAllocateHost
(
    CORE__INPUT_ARENA *arena, 
    size_t              size, 
    size_t         alignment
)
{
    uintptr_t    base_address = (uintptr_t) arena->BaseAddress + arena->NextOffset;
    uintptr_t aligned_address =  CORE_AlignUp(base_address, alignment);
    size_t        align_bytes =  aligned_address - base_address;
    size_t        alloc_bytes =  size + align_bytes;
    size_t         new_offset =  arena->NextOffset + alloc_bytes;
    if (new_offset < arena->MemorySize)
    {   /* the arena can satisfy the allocation */
        arena->NextOffset = new_offset;
        return (void*) aligned_address;
    }
    else
    {   /* the arena cannot satisfy the allocation */
        return NULL;
    }
}

/* @summary Define a stub no-op implementation of the XInputEnable API.
 * @param enable If enable is FALSE XInput will only send neutral data in response to XInputGetState.
 */
static void WINAPI
CORE__XInputEnable_Stub
(
    BOOL enable
)
{
    UNREFERENCED_PARAMETER(enable);
}

/* @summary Define a stub no-op implementation of the XInputGetState API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param state Pointer to an XINPUT_STATE structure that receives the current state of the controller.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetState_Stub
(
    DWORD            user_index, 
    struct _XINPUT_STATE *state
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(state);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputSetState API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param vibration Pointer to an XINPUT_VIBRATION structure containing vibration information to send to the controller.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputSetState_Stub
(
    DWORD                    user_index, 
    struct _XINPUT_VIBRATION *vibration
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(vibration);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetKeystroke API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param reserved This value is reserved for future use and should be set to zero.
 * @param keystroke Pointer to an XINPUT_KEYSTROKE structure that receives an input event.
 * @return ERROR_SUCCESS, ERROR_EMPTY or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetKeystroke_Stub
(
    DWORD                    user_index, 
    DWORD                      reserved, 
    struct _XINPUT_KEYSTROKE *keystroke
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(reserved);
    UNREFERENCED_PARAMETER(keystroke);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetKeystroke API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param flags Input flags that identify the controller type. Either 0 or XINPUT_FLAG_GAMEPAD.
 * @param capabilities Pointer to an XINPUT_CAPABILITIES structure that receives the controller capabilities.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetCapabilities_Stub
(
    DWORD                          user_index, 
    DWORD                               flags, 
    struct _XINPUT_CAPABILITIES *capabilities
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(flags);
    UNREFERENCED_PARAMETER(capabilities);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetBatteryInformation API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param device_type Specifies which device associated with this user index should be queried. Must be BATTERY_DEVTYPE_GAMEPAD or BATTERY_DEVTYPE_HEADSET.
 * @param battery_info Pointer to an XINPUT_BATTERY_INFORMATION that receives battery information.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetBatteryInformation_Stub
(
    DWORD                                 user_index, 
    BYTE                                 device_type, 
    struct _XINPUT_BATTERY_INFORMATION *battery_info
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(device_type);
    UNREFERENCED_PARAMETER(battery_info);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetAudioDeviceIds API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param render_device_id Windows Core Audio device ID string for render (speakers).
 * @param render_device_chars The size, in wide-chars, of the render device ID string buffer.
 * @param capture_device_id Windows Core Audio device ID string for capture (microphone).
 * @param capture_device_chars The size, in wide-chars, of the capture device ID string buffer.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetAudioDeviceIds_Stub
(
    DWORD             user_index, 
    LPWSTR      render_device_id, 
    UINT    *render_device_chars, 
    LPWSTR     capture_device_id, 
    UINT   *capture_device_chars
)
{
    if (render_device_chars != NULL) *render_device_chars = 0;
    if (capture_device_chars != NULL) *capture_device_chars = 0;
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(render_device_id);
    UNREFERENCED_PARAMETER(capture_device_id);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Attempt to load the host system XInput implementation into the process address space and resolve the XInput APIs.
 * @param disp The CORE__INPUT_XINPUT_DISPATCH structure representing the XInput API dispatch table to populate.
 * @param missing_entry_points On return, set to non-zero if any API entry points are missing and were resolved to their stub implementation.
 * @return Zero if the XInput module was loaded and XInput APIs were resolved, or -1 if XInput is not available.
 */
static int
CORE__LoadXInput
(
    CORE__INPUT_XINPUT_DISPATCH *disp, 
    int         *missing_entry_points
)
{
    HMODULE xinput = NULL;
    if ((xinput = LoadLibrary(_T("xinput1_4.dll"))) == NULL) /* Windows 8+ */
    {   /* try with XInput 9.1.0, which shipped with Vista */
        if ((xinput = LoadLibrary(_T("xinput9_1_0.dll"))) == NULL)
        {   /* try for XInput 1.3, which shipped with the June 2010 DirectX SDK */
            if ((xinput = LoadLibrary(_T("xinput1_3.dll"))) == NULL)
            {   /* no XInput is available */
                disp->XInputModule                = NULL;
                disp->XInputEnable                = CORE__XInputEnable_Stub;
                disp->XInputGetState              = CORE__XInputGetState_Stub;
                disp->XInputSetState              = CORE__XInputSetState_Stub;
                disp->XInputGetKeystroke          = CORE__XInputGetKeystroke_Stub;
                disp->XInputGetCapabilities       = CORE__XInputGetCapabilities_Stub;
                disp->XInputGetBatteryInformation = CORE__XInputGetBatteryInformation_Stub;
                disp->XInputGetAudioDeviceIds     = CORE__XInputGetAudioDeviceIds_Stub;
               *missing_entry_points = 1;
                return -1;
            }
        }
    }

    /* some version of XInput is available, resolve the function entry points */
    disp->XInputModule = xinput;
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputEnable);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetState);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputSetState);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetKeystroke);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetCapabilities);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetBatteryInformation);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetAudioDeviceIds);
   *missing_entry_points = 0;
    
    /* determine whether any API entry points could not be resolved */
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputEnable               )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetState             )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputSetState             )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetKeystroke         )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetCapabilities      )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetBatteryInformation)) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetAudioDeviceIds    )) *missing_entry_points = 1;
    return 0;
}

/* @summary Search a CORE__INPUT_DEVICE_LIST for a device identified by operating system handle.
 * @param device_list The device list to search.
 * @param device_handle The operating system identifier of the device to locate.
 * @return The zero-based index of the device in the list, or CORE_INPUT_DEVICE_NOT_FOUND.
 */
static uint32_t
CORE__FindInputDeviceForHandle
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    HANDLE                 device_handle
)
{
    uint32_t i, n;
    HANDLE *devid = device_list->DeviceHandle;
    for (i = 0, n = device_list->DeviceCount; i < n; ++i)
    {
        if (devid[i] == device_handle)
            return i;
    }
    return CORE_INPUT_DEVICE_NOT_FOUND;
}

/* @summary Handle an input device being attached to the system. If the device was not previously known, add it to a device list.
 * @param device_list The CORE__INPUT_DEVICE_LIST to query and potentially update.
 * @param device_handle The operating system identifier of the device that was attached.
 * @param default_state A pointer to a CORE__INPUT_GAMEPAD_STATE, CORE__INPUT_POINTER_STATE or CORE__INPUT_KEYBOARD_STATE initialized with the default device state.
 * @param state_size The size of the structure pointed to by default_state, in bytes.
 * @return The zero-based index of the device within the device list, or CORE_INPUT_DEVICE_TOO_MANY if too many devices of the specified type are attached.
 */
static uint32_t
CORE__HandleInputDeviceAttach
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    HANDLE                 device_handle, 
    void                  *default_state, 
    size_t                    state_size
)
{
    uint32_t i, n;
    HANDLE *devid = device_list->DeviceHandle;
    for (i = 0, n = device_list->DeviceCount; i < n; ++i)
    {
        if (devid[i] == device_handle)
        {   /* the device is already present in the list - don't modify its state */
            return i;
        }
    }
    /* add the device to the end of the device list */
    if (device_list->DeviceCount == device_list->MaxDevices)
    {   /* there are too many devices of the specified type attached */
        return CORE_INPUT_DEVICE_TOO_MANY;
    }
    CopyMemory(CORE__InputDeviceListState(device_list, i, state_size), default_state, state_size);
    device_list->DeviceHandle[i] = device_handle;
    device_list->DeviceCount++;
    return i;
}

/* @summary Handle an input device being removed from the system. If the device is known, it is removed from the device list.
 * @param device_list The CORE__INPUT_DEVICE_LIST to query and potentially update.
 * @param device_handle The operating system identifier of the device that was removed.
 * @param state_size The size of the state data structure for the device type, in bytes.
 * @return Zero if the input device was found and removed, or -1 if the device was not found.
 */
static int
CORE__HandleInputDeviceRemove
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    HANDLE                 device_handle, 
    size_t                    state_size
)
{
    if (device_list->DeviceCount > 0)
    {   /* search for the device in the device list */
        uint32_t last_index = device_list->DeviceCount - 1;
        uint32_t item_index = CORE__FindInputDeviceForHandle(device_list, device_handle);
        if (item_index != CORE_INPUT_DEVICE_NOT_FOUND)
        {   /* the device was found in the device list */
            if (item_index != last_index)
            {   /* swap the last item into place */
                CopyMemory(
                    CORE__InputDeviceListState(device_list, item_index, state_size), 
                    CORE__InputDeviceListState(device_list, last_index, state_size), 
                    state_size);
                device_list->DeviceHandle[item_index] = device_list->DeviceHandle[last_index];
            }
            device_list->DeviceCount--;
            return  0;
        }
        else
        {   /* the device was not present in the device list */
            return -1;
        }
    }
    else
    {   /* the device list was empty */
        return -1;
    }
}

/* @summary Given two snapshots of attached input devices, populate a CORE__INPUT_DEVICE_SET indicating whether a given device is in none, one or both lists.
 * @param set The device set to populate. 
 * @param prev The device list from the previous state snapshot.
 * @param curr The device list from the current state snapshot.
 */
static void
CORE__DetermineInputDeviceSet
(
    CORE__INPUT_DEVICE_SET   *set, 
    CORE__INPUT_DEVICE_LIST *prev, 
    CORE__INPUT_DEVICE_LIST *curr
)
{
    uint32_t num_prev = prev->DeviceCount;
    uint32_t num_curr = curr->DeviceCount;
    uint32_t i, j, m, n;

    /* the set always has a fixed capacity/fixed size */
    set->MaxDevices = CORE_INPUT_MAX_DEVICES_PER_TYPE * 2;

    /* initialize the state of the device set based on the previous snapshot */
    for (i = 0, n = set->MaxDevices; i < n; ++i)
    {
        if (i < num_prev)
        {   /* initialize the state data with the contents of the previous device list */
            set->DeviceIds [i] = prev->DeviceHandle[i];
            set->Membership[i] = CORE__INPUT_DEVICE_SET_MEMBERSHIP_PREV;
            set->PrevIndex [i] =(uint8_t) i;
            set->CurrIndex [i] =(uint8_t) 0xFF;
            set->DeviceCount++;
        }
        else
        {   /* initialize the state data to the default value */
            set->DeviceIds [i] = CORE_INPUT_DEVICE_HANDLE_NONE;
            set->Membership[i] = CORE__INPUT_DEVICE_SET_MEMBERSHIP_NONE;
            set->PrevIndex [i] =(uint8_t) 0xFF;
            set->CurrIndex [i] =(uint8_t) 0xFF;
        }
    }
    /* update the state of the device set based on the current snapshot */
    for (i = 0; i < num_curr; ++i)
    {   /* the set may not be empty, so filter out duplicate devices */
        HANDLE   id = curr->DeviceHandle[i];
        uint32_t ix = set->DeviceCount;
        uint32_t in = 1;
        for (j = 0; j < ix; ++j)
        {
            if (set->DeviceIds[j] == id)
            {   /* found an existing entry with the same handle */
                ix = j; /* update the existing entry */
                in = 0; /* don't increment the device count */
                break;
            }
        }
        set->DeviceIds [ix]  = id;
        set->Membership[ix] |= CORE__INPUT_DEVICE_SET_MEMBERSHIP_CURR;
        set->CurrIndex [ix]  =(uint8_t) i;
        set->DeviceCount    += in;
    }
}

/* @summary Apply scaled radial deadzone logic to an analog stick input.
 * @param stick_xymn A four-element array that will store the normalized x- and y-components of the input direction, the magnitude, and the normalized magnitude.
 * @param stick_x The x-axis component of the analog input.
 * @param stick_y The y-axis component of the analog input.
 * @param deadzone The deadzone size as a percentage of total input range (in [0, 1]).
 */
static void
CORE__ApplyInputScaledRadialDeadzone
(
    float  *stick_xymn,
    int16_t    stick_x, 
    int16_t    stick_y, 
    float     deadzone
)
{
    float  x = stick_x;
    float  y = stick_y;
    float  m =(float) sqrt(x * x + y * y);
    float nx = x / m;
    float ny = y / m;
    float  n;

    if (m < deadzone)
    {   // drop the input; it falls within the deadzone.
        stick_xymn[0] = 0;
        stick_xymn[1] = 0;
        stick_xymn[2] = 0;
        stick_xymn[3] = 0;
    }
    else
    {   // rescale the input into the non-dead space.
        n = (m - deadzone) / (1.0f - deadzone);
        stick_xymn[0] = nx * n;
        stick_xymn[1] = ny * n;
        stick_xymn[2] = m;
        stick_xymn[3] = n;
    }
}

/* @summary Process an XInput gamepad state packet to update the state of a gamepad device.
 * @param device_list The CORE__INPUT_DEVICE_LIST to query and update.
 * @param port_index The zero-based index of the port to which the gamepad is attached.
 * @param input_packet The XInput gamepad state snapshot.
 * @return The zero-based index of the device in the device list, or CORE_INPUT_DEVICE_TOO_MANY if the device was not previously seen and is not already present in the device list.
 */
static uint32_t
CORE__ProcessGamepadInputPacket
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    DWORD                     port_index, 
    XINPUT_STATE const     *input_packet
)
{
    CORE__INPUT_GAMEPAD_STATE   *state = NULL;
    XINPUT_GAMEPAD const      *gamepad =&input_packet->Gamepad;
    uintptr_t                 port_ptr =(uintptr_t) port_index;
    HANDLE                      device =(HANDLE   ) port_ptr;
    uint32_t                     index = 0;
    float                   deadzone_l = XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  / 32767.0f;
    float                   deadzone_r = XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE / 32767.0f;

    if((index = CORE__FindInputDeviceForHandle(device_list, device)) != CORE_INPUT_DEVICE_NOT_FOUND)
    {   /* this is an already-known device */
        state = CORE__GamepadDeviceListState(device_list, index);
    }
    else
    {   /* this is a newly-seen device - attach it */
        if (device_list->DeviceCount == device_list->MaxDevices)
        {   /* there are too many devices of the specified type attached */
            return CORE_INPUT_DEVICE_TOO_MANY;
        }
        index = device_list->DeviceCount;
        state = CORE__GamepadDeviceListState(device_list, index);
        ZeroMemory(state, sizeof(CORE__INPUT_GAMEPAD_STATE));
        device_list->DeviceHandle[i] = device;
        device_list->DeviceCount++;
    }

    /* update the input device state and apply deadzone logic */
    state->LTrigger = gamepad->bLeftTrigger  > XINPUT_GAMEPAD_TRIGGER_THRESHOLD ? gamepad->bLeftTrigger  : 0;
    state->RTrigger = gamepad->bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD ? gamepad->bRightTrigger : 0;
    state->Buttons  = gamepad->wButtons;
    CORE__ApplyInputScaledRadialDeadzone(state->LStick, gamepad->sThumbLX, gamepad->sThumbLY, deadzone_l);
    CORE__ApplyInputScaledRadialDeadzone(state->RStick, gamepad->sThumbRX, gamepad->sThumbRY, deadzone_r);
    return index;
}

/* @summary Process a RawInput mouse packet to update the state of a pointer device.
 * @param device_list The CORE__INPUT_DEVICE_LIST to query and update.
 * @param input_packet The RawInput mouse packet.
 * @return The zero-based index of the device in the device list, or CORE_INPUT_DEVICE_TOO_MANY if the device was not previously seen and is not already present in the device list.
 */
static uint32_t
CORE__ProcessMouseInputPacket
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    RAWINPUT const         *input_packet
)
{
    RAWINPUTHEADER       const *header = &input_packet->header;
    RAWMOUSE             const  *mouse = &input_packet->data.mouse;
    CORE__INPUT_POINTER_STATE   *state = NULL;
    uint32_t                     index = 0;
    POINT                       cursor;
    USHORT                button_flags;

    if((index = CORE__FindInputDeviceForHandle(device_list, header->hDevice)) != CORE_INPUT_DEVICE_NOT_FOUND)
    {   /* this is an already-known device */
        state = CORE__PointerDeviceListState(device_list, index);
    }
    else
    {   /* this is a newly-seen device - attach it */
        if (device_list->DeviceCount == device_list->MaxDevices)
        {   /* there are too many devices of the specified type attached */
            return CORE_INPUT_DEVICE_TOO_MANY;
        }
        index = device_list->DeviceCount;
        state = CORE__PointerDeviceListState(device_list, index);
        ZeroMemory(state, sizeof(CORE__INPUT_POINTER_STATE));
        device_list->DeviceHandle[i] = header->hDevice;
        device_list->DeviceCount++;
    }

    /* retrieve the current mouse cursor position, in pixels */
    GetCursorPos(&cursor);
    state->Pointer[0] = cursor.x;
    state->Pointer[1] = cursor.y;

    /* set the high-resolution device position values */
    if (mouse->usFlags & MOUSE_MOVE_ABSOLUTE)
    {   /* the device is a pen, touchscreen, etc. and specifies only absolute coordinates */
        state->Relative[0]  = mouse->lLastX;
        state->Relative[1]  = mouse->lLastY;
        state->Flags        = CORE__INPUT_POINTER_FLAG_ABSOLUTE;
    }
    else
    {   /* the device has specified relative coordinates */
        state->Relative[0] += mouse->lLastX;
        state->Relative[1] += mouse->lLastY;
        state->Flags        = CORE__INPUT_POINTER_FLAGS_NONE;
    }

    button_flags = mouse->usButtonFlags;
    if (button_flags & RI_MOUSE_WHEEL)
    {   /* mouse wheel data was supplied with the input packet */
        state->Relative[2] = (int16_t) mouse->usButtonData;
    }
    else
    {   /* no mouse wheel data was supplied */
        state->Relative[2] = (int16_t) 0;
    }
    /* rebuild the button state vector. Raw Input supports up to 5 buttons. */
    if (button_flags & RI_MOUSE_BUTTON_1_DOWN) state->Buttons |=  MK_LBUTTON;
    if (button_flags & RI_MOUSE_BUTTON_1_UP  ) state->Buttons &= ~MK_LBUTTON;
    if (button_flags & RI_MOUSE_BUTTON_2_DOWN) state->Buttons |=  MK_RBUTTON;
    if (button_flags & RI_MOUSE_BUTTON_2_UP  ) state->Buttons &= ~MK_RBUTTON;
    if (button_flags & RI_MOUSE_BUTTON_3_DOWN) state->Buttons |=  MK_MBUTTON;
    if (button_flags & RI_MOUSE_BUTTON_3_UP  ) state->Buttons &= ~MK_MBUTTON;
    if (button_flags & RI_MOUSE_BUTTON_4_DOWN) state->Buttons |=  MK_XBUTTON1;
    if (button_flags & RI_MOUSE_BUTTON_4_UP  ) state->Buttons &= ~MK_XBUTTON1;
    if (button_flags & RI_MOUSE_BUTTON_5_DOWN) state->Buttons |=  MK_XBUTTON2;
    if (button_flags & RI_MOUSE_BUTTON_5_UP  ) state->Buttons &= ~MK_XBUTTON2;
    return index;
}

/* @summary Process a RawInput keyboard packet to update the state of a keyboard device.
 * @param device_list The CORE__INPUT_DEVICE_LIST to query and update.
 * @param input_packet The RawInput keyboard packet.
 * @return The zero-based index of the device in the device list, or CORE_INPUT_DEVICE_TOO_MANY if the device was not previously seen and is not already present in the device list.
 */
static uint32_t
CORE__ProcessKeyboardInputPacket
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    RAWINPUT const         *input_packet
)
{
    RAWINPUTHEADER       const *header = &input_packet->header;
    RAWKEYBOARD          const    *key = &input_packet->data.keyboard;
    CORE__INPUT_KEYBOARD_STATE  *state = NULL;
    uint32_t                     index = 0;
    uint32_t                 vkey_code = 0;
    uint32_t                 scan_code = 0;

    if((index = CORE__FindInputDeviceForHandle(device_list, header->hDevice)) != CORE_INPUT_DEVICE_NOT_FOUND)
    {   /* this is an already-known device */
        state = CORE__KeyboardDeviceListState(device_list, index);
    }
    else
    {   /* this is a newly-seen device - attach it */
        if (device_list->DeviceCount == device_list->MaxDevices)
        {   /* there are too many devices of the specified type attached */
            return CORE_INPUT_DEVICE_TOO_MANY;
        }
        index = device_list->DeviceCount;
        state = CORE__KeyboardDeviceListState(device_list, index);
        ZeroMemory(state, sizeof(CORE__INPUT_KEYBOARD_STATE));
        device_list->DeviceHandle[i] = header->hDevice;
        device_list->DeviceCount++;
    }
    if (!CORE_InputGetVirtualKeyAndScanCode(&vkey_code, &scan_code, key))
    {   /* discard fake keys; these are just part of an escaped sequence */
        return index;
    }
    if ((key->Flags & RI_KEY_BREAK) == 0)
    {   /* the key is currently pressed; set the bit corresponding to the virtual key code */
        state->KeyState[vkey_code >> 5] |= (1UL << (vkey_code & 0x1F));
    }
    else
    {   /* the key was just released; clear the bit corresponding to the virtual key code */
        state->KeyState[vkey_code >> 5] &=~(1UL << (vkey_code & 0x1F));
    }
    return index;
}

/* @summary Poll all XInput gamepads currently attached to the system and update the input device state.
 * @param device_list The CORE__INPUT_DEVICE_LIST to query and possibly update.
 * @param ports_out On return, this value has one bit set for each attached gamepad.
 * @param ports_inp A bitvector specifying the gamepad ports to poll, or CORE_INPUT_ALL_GAMEPAD_PORTS to poll all ports.
 * @param disp The XInput dispatch table.
 * @return The number of gamepad devices attached to the system.
 */
static uint32_t
CORE__PollXInputGamepads
(
    CORE__INPUT_DEVICE_LIST *device_list,
    uint32_t                  *ports_out,
    uint32_t                   ports_inp, 
    CORE__INPUT_XINPUT_DISPATCH    *disp 
)
{
    XINPUT_STATE state;
    DWORD       result = ERROR_SUCCESS;
    uint32_t   outbits = 0;
    uint32_t     count = 0;
    uint32_t         i;
    for (i = 0; i < XUSER_MAX_COUNT; ++i)
    {
        if (ports_inp & (1UL << i))
        {
            if ((result  = disp->XInputGetState(i, &state)) == ERROR_SUCCESS)
            {
                CORE__ProcessGamepadInputPacket(device_list, i, &state);
                outbits |= (1UL << i);
                count++;
            }
        }
    }
   *ports_out = outbits;
    return count;
}

/* @summary Given two gamepad state snapshots, generate events for buttons down, pressed and released.
 * @param events The gamepad events structure to populate.
 * @param prev The state snapshot for the device from the previous update.
 * @param curr The state snapshot for the device from the in-progress update.
 */
static void
CORE__GenerateGamepadInputEvents
(
    CORE_INPUT_GAMEPAD_EVENTS     *events, 
    CORE__INPUT_GAMEPAD_STATE const *prev, 
    CORE__INPUT_GAMEPAD_STATE const *curr
)
{
    uint32_t   max_events = events->MaxButtonEvents;
    uint32_t   curr_state = curr->Buttons;
    uint32_t   prev_state = prev->Buttons;
    uint32_t      changes =(curr_state ^ prev_state);
    uint32_t        downs =(changes    & curr_state);
    uint32_t          ups =(changes    &~curr_state);
    uint32_t        num_d = 0;
    uint32_t        num_p = 0;
    uint32_t        num_r = 0;
    uint32_t         mask;
    uint32_t       button;
    uint32_t         i, j;

    events->LeftTrigger         = (float) curr->LTrigger / (float) (255 - XINPUT_GAMEPAD_TRIGGER_THRESHOLD);
    events->RightTrigger        = (float) curr->RTrigger / (float) (255 - XINPUT_GAMEPAD_TRIGGER_THRESHOLD);
    events->LeftStick[0]        =  curr->LStick[0];
    events->LeftStick[1]        =  curr->LStick[1];
    events->LeftStickMagnitude  =  curr->LStick[3];
    events->RightStick[0]       =  curr->RStick[0];
    events->RightStick[1]       =  curr->RStick[1];
    events->RightStickMagnitude =  curr->RStick[3];
    for (i = 0; i < 32; ++i)
    {
        mask    = 1UL << i;
        button  = mask; /* XINPUT_GAMEPAD_x */

        if (num_d < max_events && (curr_state & mask) != 0)
        {   /* this button is currently pressed */
            events->ButtonsDown[num_d++] = (uint16_t) button;
        }
        if (num_p < max_events && (downs & mask) != 0)
        {   /* this button was just pressed */
            events->ButtonsPressed[num_p++] = (uint16_t) button;
        }
        if (num_r < max_events && (ups & mask) != 0)
        {   /* this button was just released */
            events->ButtonssReleased[num_r++] = (uint16_t) button;
        }
    }
    events->ButtonDownCount     = num_d;
    events->ButtonPressedCount  = num_p;
    events->ButtonReleasedCount = num_r;
}

/* @summary Given two pointer state snapshots, generate events for keys down, pressed and released.
 * @param events The keyboard events structure to populate.
 * @param prev The state snapshot for the device from the previous update.
 * @param curr The state snapshot for the device from the in-progress update.
 */
static void
CORE__GeneratePointerInputEvents
(
    CORE_INPUT_POINTER_EVENTS     *events, 
    CORE__INPUT_POINTER_STATE const *prev, 
    CORE__INPUT_POINTER_STATE const *curr
)
{
    uint32_t   max_events = events->MaxButtonEvents;
    uint32_t   curr_state = curr->Buttons;
    uint32_t   prev_state = prev->Buttons;
    uint32_t      changes =(curr_state ^ prev_state);
    uint32_t        downs =(changes    & curr_state);
    uint32_t          ups =(changes    &~curr_state);
    uint32_t        num_d = 0;
    uint32_t        num_p = 0;
    uint32_t        num_r = 0;
    uint32_t         mask;
    uint32_t       button;
    uint32_t         i, j;

    events->Cursor[0]  = curr->Pointer [0];
    events->Cursor[1]  = curr->Pointer [1];
    events->WheelDelta = curr->Relative[2];
    if (curr->Flags & CORE__INPUT_POINTER_FLAG_ABSOLUTE)
    {   /* calculate relative values as the delta between states */
        events->Mickeys[0] = curr->Relative[0] - prev->Relative[0];
        events->Mickeys[1] = curr->Relative[1] - prev->Relative[1];
    }
    else
    {   /* the driver specified relative values - copy them as-is */
        events->Mickeys[0] = curr->Relative[0];
        events->Mickeys[1] = curr->Relative[1];
    }
    for (i = 0; i < 32; ++i)
    {
        mask    = 1UL << i;
        button  = mask; /* MK_nBUTTON */

        if (num_d < max_events && (curr_state & mask) != 0)
        {   /* this button is currently pressed */
            events->ButtonsDown[num_d++] = (uint16_t) button;
        }
        if (num_p < max_events && (downs & mask) != 0)
        {   /* this button was just pressed */
            events->ButtonsPressed[num_p++] = (uint16_t) button;
        }
        if (num_r < max_events && (ups & mask) != 0)
        {   /* this button was just released */
            events->ButtonssReleased[num_r++] = (uint16_t) button;
        }
    }
    events->ButtonDownCount     = num_d;
    events->ButtonPressedCount  = num_p;
    events->ButtonReleasedCount = num_r;
}

/* @summary Given two keyboard state snapshots, generate events for keys down, pressed and released.
 * @param events The keyboard events structure to populate.
 * @param prev The state snapshot for the device from the previous update.
 * @param curr The state snapshot for the device from the in-progress update.
 */
static void
CORE__GenerateKeyboardInputEvents
(
    CORE_INPUT_KEYBOARD_EVENTS     *events, 
    CORE__INPUT_KEYBOARD_STATE const *prev, 
    CORE__INPUT_KEYBOARD_STATE const *curr
)
{
    uint32_t   max_events = events->MaxKeyEvents;
    uint32_t        num_d = 0;
    uint32_t        num_p = 0;
    uint32_t        num_r = 0;
    uint32_t   curr_state;
    uint32_t   prev_state;
    uint32_t      changes;
    uint32_t        downs;
    uint32_t          ups;
    uint32_t         mask;
    uint32_t         vkey;
    uint32_t         i, j;

    for (i = 0; i < 8; ++i)
    {
        curr_state = curr->KeyState[i];
        prev_state = prev->KeyState[i];
        changes    =(curr_state ^ prev_state);
        downs      =(changes    & curr_state);
        ups        =(changes    &~curr_state);
        for (j = 0; j < 32; ++j)
        {
            mask = 1UL << j;
            vkey =  (i << 5) + j;

            if (num_d < max_events && (curr_state & mask) != 0)
            {   /* this key is currently pressed */
                events->KeysDown[num_d++] = (uint8_t) vkey;
            }
            if (num_p < max_events && (downs & mask) != 0)
            {   /* this key was just pressed */
                events->KeysPressed[num_p++] = (uint8_t) vkey;
            }
            if (num_r < max_events && (ups & mask) != 0)
            {   /* this key was just released */
                events->KeysReleased[num_r++] = (uint8_t) vkey;
            }
        }
    }
    events->KeyDownCount     = num_d;
    events->KeyPressedCount  = num_p;
    events->KeyReleasedCount = num_r;
}

/* @summary Build a device set and generate events related to device attachment and removal.
 * @param events The CORE_INPUT_EVENTS to update.
 * @param device_set A CORE__INPUT_DEVICE_SET to populate with information about ...
 * @param device_list_prev 
 * @param device_list_curr
 */
static void
CORE__GenerateKeyboardDeviceEvents
(
    CORE_INPUT_EVENTS                 *events, 
    CORE__INPUT_DEVICE_SET        *device_set, 
    CORE__INPUT_DEVICE_LIST *device_list_prev, 
    CORE__INPUT_DEVICE_LIST *device_list_curr
)
{
}

CORE_API(int)
CORE_InputGetVirtualKeyAndScanCode
(
    uint32_t    *vkey_code, 
    uint32_t    *scan_code,
    RAWKEYBOARD const *key 
)
{
    uint32_t vkey = key.VKey;
    uint32_t scan = key.MakeCode;
    uint32_t   e0 = key.Flags & RI_KEY_E0;

    if (vkey == 255)
    {   /* discard fake keys; these are just part of an escaped sequence */
       *vkey_code = 0;
       *scan_code = 0;
        return 0;
    }
    if (vkey == VK_SHIFT)
    {   /* correct left/right shift */
        vkey  = MapVirtualKey(scan, MAPVK_VSC_TO_VK_EX);
    }
    if (vkey == VK_NUMLOCK)
    {   /* correct PAUSE/BREAK and NUMLOCK. set the extended bit */
        scan  = MapVirtualKey(vkey, MAPVK_VK_TO_VSC) | 0x100;
    }
    if (key.Flags & RI_KEY_E1)
    {   /* for escaped sequences, turn the virtual key into the correct scan code.
         * unfortunately, MapVirtualKey can't handle VK_PAUSE, so do that manually. */
        if (vkey != VK_PAUSE) scan = MapVirtualKey(vkey, MAPVK_VK_TO_VSC);
        else scan = 0x45;
    }
    switch (vkey)
    {   /* map left/right versions of various keys */
        case VK_CONTROL:  /* left/right CTRL */
            vkey =  e0 ? VK_RCONTROL : VK_LCONTROL;
            break;
        case VK_MENU:     /* left/right ALT  */
            vkey =  e0 ? VK_RMENU : VK_LMENU;
            break;
        case VK_RETURN:
            vkey =  e0 ? VK_SEPARATOR : VK_RETURN;
            break;
        case VK_INSERT:
            vkey = !e0 ? VK_NUMPAD0 : VK_INSERT;
            break;
        case VK_DELETE:
            vkey = !e0 ? VK_DECIMAL : VK_DELETE;
            break;
        case VK_HOME:
            vkey = !e0 ? VK_NUMPAD7 : VK_HOME;
            break;
        case VK_END:
            vkey = !e0 ? VK_NUMPAD1 : VK_END;
            break;
        case VK_PRIOR:
            vkey = !e0 ? VK_NUMPAD9 : VK_PRIOR;
            break;
        case VK_NEXT:
            vkey = !e0 ? VK_NUMPAD3 : VK_NEXT;
            break;
        case VK_LEFT:
            vkey = !e0 ? VK_NUMPAD4 : VK_LEFT;
            break;
        case VK_RIGHT:
            vkey = !e0 ? VK_NUMPAD6 : VK_RIGHT;
            break;
        case VK_UP:
            vkey = !e0 ? VK_NUMPAD8 : VK_UP;
            break;
        case VK_DOWN:
            vkey = !e0 ? VK_NUMPAD2 : VK_DOWN;
            break;
        case VK_CLEAR:
            vkey = !e0 ? VK_NUMPAD5 : VK_CLEAR;
            break;
    }
   *vkey_code = vkey;
   *scan_code = scan;
    return 1;
}

CORE_API(size_t)
CORE_InputCopyKeyDisplayName
(
    WCHAR           *buffer, 
    size_t buffer_max_chars, 
    uint32_t      vkey_code
)
{
    uint32_t scan_code = 0;
    uint32_t        e0 = 0;

    if (vkey_code != VK_PAUSE)
    {   /* map the virtual key code to the scan code */
        if (vkey_code != VK_NUMLOCK)
        {   /* common case - map the virtual key code to the scan code */
            scan_code  = MapVirtualKey(vkey_code, MAPVK_VK_TO_VSC);
        }
        else
        {   /* correct PAUSE/BREAK and NUMLOCK - set the extended bit */
            scan_code  = MapVirtualKey(vkey_code, MAPVK_VK_TO_VSC) | 0x100;
        }
    }
    else
    {   /* correctly handle VK_PAUSE */
        scan_code = 0x45;
    }
    /* determine whether to set the extended-key flag */
    if (vkey_code == VK_RCONTROL || vkey_code == VK_RMENU  || vkey_code == VK_SEPARATOR || 
        vkey_code == VK_INSERT   || vkey_code == VK_DELETE || vkey_code == VK_HOME      || 
        vkey_code == VK_END      || vkey_code == VK_PRIOR  || vkey_code == VK_NEXT      || 
        vkey_code == VK_LEFT     || vkey_code == VK_RIGHT  || vkey_code == VK_UP        || 
        vkey_code == VK_DOWN     || vkey_code == VK_CLEAR)
    {   /* set the extended key flag */
        e0 = 1;
    }
    return (size_t)GetKeyNameTextW((LONG)((scan_code << 16) | (e0 << 24)), buffer, (int) buffer_max_chars);
}

CORE_API(size_t)
CORE_QueryInputSystemMemorySize
(
    CORE_INPUT_SYSTEM_INIT *init
)
{
    size_t required_size = 0;
    size_t   events_size = 0;
    uint32_t        i, n;
    /* calculate the amount of memory required for the data stored directly in _CORE_INPUT_SYSTEM.
     * this includes the size of the structure itself, since all data is private.
     */
    required_size += CORE__InputAllocationSizeType (CORE__INPUT_SYSTEM);
    required_size += CORE__InputAllocationSizeArray(CORE_INPUT_EVENTS*, init->MaxInputEventsInFlight); /* InputEventsQueue */
    required_size += CORE__InputAllocationSizeArray(CORE_INPUT_EVENTS*, init->MaxInputEventsInFlight); /* InputEvents      */
    /* calculate the amount of memory required for each _CORE_INPUT_EVENTS in the pool */
    events_size   += CORE__InputAllocationSizeType (CORE_INPUT_EVENTS);
    // TODO: Device lists
    if (init->MaxGamepadDevices > 0)
    {   events_size += CORE__InputAllocationSizeArray(DWORD                     , init->MaxGamepadDevices);  /* GamepadDeviceIds     */
        events_size += CORE__InputAllocationSizeArray(CORE_INPUT_GAMEPAD_EVENTS , init->MaxGamepadDevices);  /* GamepadDeviceEvents  */
        events_size += CORE__InputAllocationSizeArray(DWORD                     , init->MaxGamepadDevices);  /* GamepadAttachList    */
        events_size += CORE__InputAllocationSizeArray(DWORD                     , init->MaxGamepadDevices);  /* GamepadRemoveList    */
        events_size += CORE__InputAllocationSizeArray(uint16_t, init->MaxEventsPerGamepad * 3) * init->MaxGamepadDevices; /* ButtonsDown/Pressed/Released */
    }
    if (init->MaxPointerDevices > 0)
    {   events_size += CORE__InputAllocationSizeArray(HANDLE                    , init->MaxPointerDevices);  /* PointerDeviceIds     */
        events_size += CORE__InputAllocationSizeArray(CORE_INPUT_POINTER_EVENTS , init->MaxPointerDevices);  /* PointerDeviceEvents  */
        events_size += CORE__InputAllocationSizeArray(HANDLE                    , init->MaxPointerDevices);  /* PointerAttachList    */
        events_size += CORE__InputAllocationSizeArray(HANDLE                    , init->MaxPointerDevices);  /* PointerRemoveList    */
        events_size += CORE__InputAllocationSizeArray(uint16_t, init->MaxEventsPerPointer * 3) * init->MaxPointerDevices; /* ButtonsDown/Pressed/Released */
    }
    if (init->MaxKeyboardDevices > 0)
    {   events_size += CORE__InputAllocationSizeArray(HANDLE                    , init->MaxKeyboardDevices); /* KeyboardDeviceIds    */
        events_size += CORE__InputAllocationSizeArray(CORE_INPUT_KEYBOARD_EVENTS, init->MaxKeyboardDevices); /* KeyboardDeviceEvents */
        events_size += CORE__InputAllocationSizeArray(HANDLE                    , init->MaxKeyboardDevices); /* KeyboardAttachList   */
        events_size += CORE__InputAllocationSizeArray(HANDLE                    , init->MaxKeyboardDevices); /* KeyboardRemoveList   */
        events_size += CORE__InputAllocationSizeArray(uint8_t, init->MaxEventsPerKeyboard * 3) * init->MaxKeyboardDevices; /* KeysDown/Pressed/Released */
    }
    /* calculate the total memory required for all data */
    required_size +=(events_size * init->MaxInputEventsInFlight);
    return required_size;
}

CORE_API(int)
CORE_CreateInputSystem
(
    struct _CORE_INPUT_SYSTEM **input_system,
    CORE_INPUT_SYSTEM_INIT             *init
)
{
    CORE__INPUT_ARENA    arena;
    CORE__INPUT_SYSTEM *system = NULL;
    CORE_INPUT_EVENTS  *events = NULL;
    size_t       required_size = 0;
    int   missing_entry_points = 0;
    uint32_t        i, j, n, m;

    if (init->SourceWindow == NULL)
    {   /* the source window must be specified */
        assert(init->SourceWindow != NULL);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }
    if (init->MemoryStart == NULL || init->MemorySize == 0)
    {   /* the caller must supply memory for the input system data */
        assert(init->MemoryStart != NULL);
        assert(init->MemorySize > 0);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }
    if (init->MaxPointerDevices  > CORE_INPUT_MAX_DEVICES_PER_TYPE || 
        init->MaxGamepadDevices  > CORE_INPUT_MAX_DEVICES_PER_TYPE || 
        init->MaxKeyboardDevices > CORE_INPUT_MAX_DEVICES_PER_TYPE)
    {   /* the caller wants to enable more than the maximum allowable number of devices per-type */
        assert(init->MaxPointerDevices  <= CORE_INPUT_MAX_DEVICES_PER_TYPE);
        assert(init->MaxGamepadDevices  <= CORE_INPUT_MAX_DEVICES_PER_TYPE);
        assert(init->MaxKeyboardDevices <= CORE_INPUT_MAX_DEVICES_PER_TYPE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }
    if (init->MaxEventsPerPointer > CORE_INPUT_MAX_BUTTONS || 
        init->MaxEventsPerGamepad > CORE_INPUT_MAX_BUTTONS)
    {   /* the caller wants to support devices with many (> 32) buttons */
        assert(init->MaxEventsPerPointer <= CORE_INPUT_MAX_BUTTONS);
        assert(init->MaxEventsPerGamepad <= CORE_INPUT_MAX_BUTTONS);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }
    if (init->MaxEventsPerKeyboard > CORE_INPUT_MAX_KEYS)
    {   /* the caller wants more than 256 key events */
        assert(init->MaxEventsPerKeyboard <= CORE_INPUT_MAX_KEYS);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }
    if (init->MaxInputEventsInFlight == 0)
    {   /* there must be at least one input events buffer */
        assert(init->MaxInputEventsInFlight > 0);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    required_size = CORE_QueryInputSystemMemorySize(init);
    if (init->MemorySize < required_size)
    {   /* the caller must supply sufficient memory for the storage object */
        assert(init->MemorySize >= required_size);
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    /* zero-initialize the entire memory block and allocate the base structure */
    ZeroMemory(init->MemoryStart, (size_t) init->MemorySize);
    CORE__InputInitMemoryArena(&arena, init->MemoryStart, (size_t) init->MemorySize);
    system = CORE__InputMemoryArenaAllocateType(&arena, CORE__INPUT_SYSTEM);
    if (!InitializeCriticalSectionAndSpinCount(&system->WriterLock, 0x1000))
    {   /* this should never happen on XP and above */
       *input_system = NULL;
        return -1;
    }
    if (!InitializeCriticalSectionAndSpinCount(&system->ReturnLock, 0x1000))
    {   /* this should never happen on XP and above */
        DeleteCriticalSection(&system->WriterLock);
       *input_system = NULL;
        return -1;
    }
    if ((system->QueueSemaphore = CreateSemaphore(NULL, (LONG) init->MaxInputEventsInFlight, (LONG) init->MaxInputEventsInFlight, NULL)) == NULL)
    {   /* failed to create the semaphore used to throttle event snapshot consumption */
        goto cleanup_and_fail;
    }
    if (init->MaxGamepadDevices > 0)
    {   /* the user has enabled gamepad devices, so load XInput */
        CORE__LoadXInput(&system->XInput, &missing_entry_points);
    }
    /* allocate the arrays within the input system */
    system->InputEventsQueue = CORE__InputMemoryArenaAllocateArray(CORE_INPUT_EVENTS*, init->MaxInputEventsInFlight);
    system->InputEvents      = CORE__InputMemoryArenaAllocateArray(CORE_INPUT_EVENTS*, init->MaxInputEventsInFlight);
    system->InputEventsCount = init->MaxInputEventsInFlight;
    system->QueueHead        = 0;
    system->WriteIndex       = 0;
    system->GamepadPorts[0]  = 0;
    system->GamepadPorts[1]  = 0;
    system->QueueTail        = init->MaxInputEventsInFlight - 1;
    system->MemoryStart      = init->MemoryStart;
    system->MemorySize       = init->MemorySize;
    system->SourceWindow     = init->SourceWindow;
    /* allocate the device lists */
    for (i = 0; i < 2; ++i)
    {
        system->GamepadDeviceList [i].MaxDevices  = init->MaxGamepadDevices;
        system->GamepadDeviceList [i].DeviceCount = 0;
        system->PointerDeviceList [i].MaxDevices  = init->MaxPointerDevices;
        system->PointerDeviceList [i].DeviceCount = 0;
        system->KeyboardDeviceList[i].MaxDevices  = init->MaxKeyboardDevices;
        system->KeyboardDeviceList[i].DeviceCount = 0;
        if (init->MaxGamepadDevices > 0)
        {   /* allocate the arrays for the device list */
            system->GamepadDeviceList[i].DeviceHandle = CORE__InputMemoryArenaAllocateArray(HANDLE                   , init->MaxGamepadDevices);
            system->GamepadDeviceList[i].DeviceState  = CORE__InputMemoryArenaAllocateArray(CORE__INPUT_GAMEPAD_STATE, init->MaxGamepadDevices);
        }
        else
        {   /* the user has not enabled gamepad device support */
            system->GamepadDeviceList[i].DeviceHandle = NULL;
            system->GamepadDeviceList[i].DeviceState  = NULL;
        }
        if (init->MaxPointerDevices > 0)
        {   /* allocate the arrays for the device list */
            system->PointerDeviceList[i].DeviceHandle = CORE__InputMemoryArenaAllocateArray(HANDLE                   , init->MaxPointerDevices);
            system->PointerDeviceList[i].DeviceState  = CORE__InputMemoryArenaAllocateArray(CORE__INPUT_POINTER_STATE, init->MaxPointerDevices);
        }
        else
        {   /* the user has not enabled pointer device support */
            system->PointerDeviceList[i].DeviceHandle = NULL;
            system->PointerDeviceList[i].DeviceState  = NULL;
        }
        if (init->MaxKeyboardDevices > 0)
        {   /* allocate the arrays for the device list */
            system->KeyboardDeviceList[i].DeviceHandle = CORE__InputMemoryArenaAllocateArray(HANDLE                    , init->MaxKeyboardDevices);
            system->KeyboardDeviceList[i].DeviceState  = CORE__InputMemoryArenaAllocateArray(CORE__INPUT_KEYBOARD_STATE, init->MaxKeyboardDevices);
        }
        else
        {   /* the user has not enabled keyboard device support */
            system->KeyboardDeviceList[i].DeviceHandle = NULL;
            system->KeyboardDeviceList[i].DeviceState  = NULL;
        }
    }
    /* allocate the event buffers */
    for (i = 0, n = init->MaxInputEventsInFlight; i < n; ++i)
    {   /* initialize the individual CORE_INPUT_EVENTS object */
        events= CORE__InputMemoryArenaAllocateType(CORE_INPUT_EVENTS);
        events->InputSystem         = system;
        events->NextEvents          = NULL;
        events->StartTime           = 0;
        events->CaptureTime         = 0;
        events->MaxGamepadDevices   = init->MaxGamepadDevices;
        events->MaxPointerDevices   = init->MaxPointerDevices;
        events->MaxKeyboardDevices  = init->MaxKeyboardDevices;
        if (init->MaxGamepadDevices > 0)
        {   /* allocate the arrays for the gamepad devices */
            events->GamepadDeviceIds    = CORE__InputMemoryArenaAllocateArray(DWORD                    , init->MaxGamepadDevices);
            events->GamepadAttachList   = CORE__InputMemoryArenaAllocateArray(DWORD                    , init->MaxGamepadDevices);
            events->GamepadRemoveList   = CORE__InputMemoryArenaAllocateArray(DWORD                    , init->MaxGamepadDevices);
            events->GamepadDeviceEvents = CORE__InputMemoryArenaAllocateArray(CORE_INPUT_GAMEPAD_EVENTS, init->MaxGamepadDevices);
            for (j = 0, m = init->MaxGamepadDevices; j < m; ++j)
            {
                CORE_INPUT_GAMEPAD_EVENTS *device_ev = &events->GamepadDeviceEvents[j];
                device_ev->MaxButtonEvents = init->MaxEventsPerGamepad;
                device_ev->ButtonsDown     = CORE__InputMemoryArenaAllocateArray(uint16_t, init->MaxEventsPerGamepad);
                device_ev->ButtonsPressed  = CORE__InputMemoryArenaAllocateArray(uint16_t, init->MaxEventsPerGamepad);
                device_ev->ButtonsReleased = CORE__InputMemoryArenaAllocateArray(uint16_t, init->MaxEventsPerGamepad);
            }
        }
        else
        {   /* the user has not enabled gamepad device support */
            events->GamepadDeviceIds    = NULL;
            events->GamepadAttachList   = NULL;
            events->GamepadRemoveList   = NULL;
            events->GamepadDeviceEvents = NULL;
        }
        if (init->MaxPointerDevices > 0)
        {   /* allocate the arrays for the pointer devices */
            events->PointerDeviceIds    = CORE__InputMemoryArenaAllocateArray(HANDLE                   , init->MaxPointerDevices);
            events->PointerAttachList   = CORE__InputMemoryArenaAllocateArray(HANDLE                   , init->MaxPointerDevices);
            events->PointerRemoveList   = CORE__InputMemoryArenaAllocateArray(HANDLE                   , init->MaxPointerDevices);
            events->PointerDeviceEvents = CORE__InputMemoryArenaAllocateArray(CORE_INPUT_POINTER_EVENTS, init->MaxPointerDevices);
            for (j = 0, m = init->MaxPointerDevices; j < m; ++j)
            {
                CORE_INPUT_POINTER_EVENTS *device_ev = &events->PointerDeviceEvents[j];
                device_ev->MaxButtonEvents = init->MaxEventsPerPointer;
                device_ev->ButtonsDown     = CORE__InputMemoryArenaAllocateArray(uint16_t, init->MaxEventsPerPointer);
                device_ev->ButtonsPressed  = CORE__InputMemoryArenaAllocateArray(uint16_t, init->MaxEventsPerPointer);
                device_ev->ButtonsReleased = CORE__InputMemoryArenaAllocateArray(uint16_t, init->MaxEventsPerPointer);
            }
        }
        else
        {   /* the user has not enabled pointer device support */
            events->PointerDeviceIds    = NULL;
            events->PointerAttachList   = NULL;
            events->PointerRemoveList   = NULL;
            events->PointerDeviceEvents = NULL;
        }
        if (init->MaxKeyboardDevices > 0)
        {   /* allocate the arrays for the keyboard devices */
            events->KeyboardDeviceIds    = CORE__InputMemoryArenaAllocateArray(HANDLE                    , init->MaxKeyboardDevices);
            events->KeyboardAttachList   = CORE__InputMemoryArenaAllocateArray(HANDLE                    , init->MaxKeyboardDevices);
            events->KeyboardRemoveList   = CORE__InputMemoryArenaAllocateArray(HANDLE                    , init->MaxKeyboardDevices);
            events->KeyboardDeviceEvents = CORE__InputMemoryArenaAllocateArray(CORE_INPUT_KEYBOARD_EVENTS, init->MaxKeyboardDevices);
            for (j = 0, m = init->MaxKeyboardDevices; j < m; ++j)
            {
                CORE_INPUT_KEYBOARD_EVENTS *device_ev = &events->KeyboardDeviceEvents[j];
                device_ev->MaxKeyEvents  = init->MaxEventsPerKeyboard;
                device_ev->KeysDown      = CORE__InputMemoryArenaAllocateArray(uint8_t, init->MaxEventsPerKeyboard);
                device_ev->KeysPressed   = CORE__InputMemoryArenaAllocateArray(uint8_t, init->MaxEventsPerKeyboard);
                device_ev->KeysReleased  = CORE__InputMemoryArenaAllocateArray(uint8_t, init->MaxEventsPerKeyboard);
            }
        }
        else
        {   /* the user has not enabled keyboard device support */
            events->KeyboardDeviceIds    = NULL;
            events->KeyboardAttachList   = NULL;
            events->KeyboardRemoveList   = NULL;
            events->KeyboardDeviceEvents = NULL;
        }
    }
   *input_system = system;
    return 0;

cleanup_and_fail:
    if (system->XInput.XInputModule != NULL)
    {
        FreeLibrary(system->XInput.XInputModule); 
    }
    DeleteCriticalSection(&system->ReturnLock);
    DeleteCriticalSection(&system->WriterLock);
    CloseHandle(system->QueueSemaphore);
   *input_system = NULL;
    return -1;
}
#if 0
There are three players here. There is one system per-window.
1. Thread managing the window and pushing data into the system.
   Only one thread can fill role #1.
   This thread must synchronize with #2.
   This thread writes to the current 'write buffer'.
2. Thread attempting to grab an event snapshot.
   Only one thread can fill role #2, though it may poll one system per-window.
   This thread must synchronize with one thread filling role #1.
   - It swaps the buffers, and takes ownership of the previous 'write buffer'.
   This thread must synchronize with one or more threads filling role #3.
   - It attempts to take an event buffer from the head of the FIFO.
   - The calling thread must block until an event buffer is available.
3. Thread attempting to return an event buffer that is no longer needed.
   More than one thread can fill role #3.
   This thread must synchronize with zero or more threads filling role #3.
   - It only updates the tail of the queue and returns very quickly.

Basically, the system maintains a semaphore initialized with the maximum number of in-flight frames.
There's also a CRITICAL_SECTION used to synchronize concurrent #3. 
Given indices H and T, the initial state is:
- Sem(Capacity)
- CS_WRITEBUF
- CS_RETURN
- H = 0
- T = Capacity - 1
- dbuf

A thread #1 does:
Enter(CS_WRITEBUF)
ProcessData(packet, device_list[dbuf])
Leave(CS_WRITEBUF)

A thread #2 does:
Wait(Sem); /* when this unblocks, an item is available */
slot = head % Capacity;
item = stor[slot];
head++
Enter(CS_WRITEBUF)
sbuf = dbuf      /* sbuf is the buffer we will read from - the previous write buffer */
dbuf = 1 - dbuf; /* dbuf is the buffer thread #1 will write to */
Leave(CS_WRITEBUF)

A thread #3 does:
Enter(CS_RETURN)
slot = tail % Capacity;
stor[slot] = item
tail++
Leave(CS_RETURN)
Make(Sem) /* make an item available for a thread #2 */

Really, there is only ever one events object in flight at any one time in a naive implementation.
The frame launch collects an events object from each window. These are used until the frame completes.
The next frame launch cannot begin until the in-flight frame completes.
This holds as long as a frame can be completed in a single tick.
If the tick rate is very high, say 240Hz, this may not hold. It might also not be a good idea, because 
you're "spawn a bunch of work, and wait until it drains completely". This fails to keep the system busy, 
for example, you fire off a frame, but the images are not all ready in time, so you have some workers 
busy and others idle. You can either wait and be unresponsive, missing input and falling behind, or 
potentially launch the next frame and use the idle workers to get a head start.
#endif
typedef struct _CORE_INPUT_EVENTS {
    struct _CORE_INPUT_SYSTEM    *InputSystem;            /* The _CORE_INPUT_SYSTEM that owns the input event buffer. */
    struct _CORE_INPUT_EVENTS    *NextEvents;             /* A pointer to the next item in the queue. User code always sees this value as NULL. */
    uint64_t                      StartTime;              /* The timestamp, in nanoseconds, at which the input event interval began. */
    uint64_t                      CaptureTime;            /* The timestamp, in nanoseconds, at which the input events were retrieved by the application. */
    uint32_t                      MaxGamepadDevices;      /* The maximum number of gamepad devices that can be attached to the system. This value defines the dimensions of the GamepadAttachList/GamepadRemoveList/GamepadDeviceIds/GamepadDeviceEvents arrays. */
    uint32_t                      GamepadAttachCount;     /* The number of gamepad devices that were attached to the system since the last poll. This value defines the number of valid entries in the GamepadAttachList array. */
    uint32_t                      GamepadRemoveCount;     /* The number of gamepad devices that were detached from the system since the last poll. This value defines the number of valid entries in the GamepadRemoveList array. */
    uint32_t                      GamepadDeviceCount;     /* The number of gamepad devices that are currently attached to the system. This value defines the number of valid entries in the GamepadDeviceIds and GamepadDeviceEvents arrays. */
    DWORD                        *GamepadDeviceIds;       /* An array of GamepadDeviceCount entries specifying the port numbers to which active gamepads are attached. */
    CORE_INPUT_GAMEPAD_EVENTS    *GamepadDeviceEvents;    /* An array of GamepadDeviceCount entries specifying the input events that have occurred for each attached gamepad device. */
    DWORD                        *GamepadAttachList;      /* An array of GamepadAttachCount entries specifying the port IDs to which gamepad devices were attached since the last poll. */
    DWORD                        *GamepadRemoveList;      /* An array of GamepadRemoveCount entries specifying the port IDs from which gamepad devices were removed since the last poll.*/
    uint32_t                      MaxPointerDevices;      /* The maximum number of pointer devices that can be attached to the system. This value defines the dimensions of the PointerAttachList/PointerRemoveList/PointerDeviceIds/PointerDeviceEvents arrays. */
    uint32_t                      PointerAttachCount;     /* The number of pointer devices that were attached to the system since the last poll. This value defines the number of valid entries in the PointerAttachList array. */
    uint32_t                      PointerRemoveCount;     /* The number of pointer devices that were detached from the system since the last poll. This value defines the number of valid entries in the PointerRemoveList array. */
    uint32_t                      PointerDeviceCount;     /* The number of pointer devices that are currently attached to the system. This value defines the number of valid entries in the PointerDeviceIds and PointerDeviceEvents arrays. */
    HANDLE                       *PointerDeviceIds;       /* An array of PointerDeviceCount handles specifying unique identifiers for each pointer device attached to the system. */
    CORE_INPUT_POINTER_EVENTS    *PointerDeviceEvents;    /* An array of PointerDeviceCount entries specifying the input events that have occurred since the last poll for each pointer device. */
    HANDLE                       *PointerAttachList;      /* An array of PointerAttachCount entries specifying the device identifiers for each pointer device attached to the system since the last poll. */
    HANDLE                       *PointerRemoveList;      /* An array of PointerRemoveCount entries specifying the device identifiers for each pointer device detached from the system since the last poll. */
    uint32_t                      MaxKeyboardDevices;     /* The maximum number of keyboard devices that can be attached to the system. This value defines the dimensions of the KeyboardAttachList/KeyboardRemoveList/KeyboardDeviceIds/KeyboardDeviceEvents arrays. */
    uint32_t                      KeyboardAttachCount;    /* The number of keyboard devices that were attached to the system since the last poll. This value defines the number of valid entries in the KeyboardAttachList array. */
    uint32_t                      KeyboardRemoveCount;    /* The number of keyboard devices that were removed from the system since the last poll. This value defines the number of valid entries in the KeyboardRemoveList array. */
    uint32_t                      KeyboardDeviceCount;    /* The number of keyboard devices that are currently attached to the system. This value defines the number of valid entires in the KeyboardDeviceIds and KeyboardDeviceEvents arrays. */
    HANDLE                       *KeyboardDeviceIds;      /* An array of KeyboardDeviceCount entries specifying unique device identifiers for each keyboard device attached to the system. */
    CORE_INPUT_KEYBOARD_EVENTS   *KeyboardDeviceEvents;   /* An array of KeyboardDeviceCount entries specifying the input events that have occurred since the last poll for each keyboard device. */
    HANDLE                       *KeyboardAttachList;     /* An array of KeyboardAttachCount entries specifying the device identifier for each keyboard device attached to the system since the last poll. */
    HANDLE                       *KeyboardRemoveList;     /* An array of KeyboardRemoveCount entries specifying the device identifier for each keyboard device removed from the system since the last poll. */
} CORE_INPUT_EVENTS;
typedef struct _CORE_INPUT_SYSTEM_INIT {
    uint32_t                      MaxPointerDevices;      /* The maximum number of supported pointer devices attached to the system at any one time. */
    uint32_t                      MaxGamepadDevices;      /* The maximum number of supported gamepad devices attached to the system at any one time. */
    uint32_t                      MaxKeyboardDevices;     /* The maximum number of supported keyboard devices attached to the system at any one time. */
    uint32_t                      MaxEventsPerGamepad;    /* The maximum number of button events that should be reported per gamepad device. */
    uint32_t                      MaxEventsPerPointer;    /* The maximum number of button events that should be reported per pointer device. */
    uint32_t                      MaxEventsPerKeyboard;   /* The maximum number of key events that should be reported per keyboard device. */
    uint32_t                      MaxInputEventsInFlight; /* The maximum number of _CORE_INPUT_EVENTS structures expected to be in use at any one time. */
} CORE_INPUT_SYSTEM_INIT;

#endif /* CORE_INPUT_IMPLEMENTATION */

