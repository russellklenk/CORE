/*
 * CORE_input.h: A single-file library for working with keyboards, pointing 
 * devices and gamepads using RawInput and XInput. One thread pushes input and 
 * device events into the input system as they occur. For each application tick,
 * an input event snapshot is acquired and treated as read-only for the duration
 * of the tick. Once the tick completes, the input event snapshot is returned 
 * to the input system.
 *
 * This software is dual-licensed to the public domain and under the following 
 * license: You are hereby granted a perpetual, irrevocable license to copy, 
 * modify, publish and distribute this file as you see fit.
 *
 */
#ifndef __CORE_INPUT_H__
#define __CORE_INPUT_H__

/* #define CORE_STATIC to make all function declarations and definitions static.     */
/* This is useful if the library needs to be included multiple times in the project. */
#ifdef  CORE_STATIC
#define CORE_API(_rt)                     static _rt
#else
#define CORE_API(_rt)                     extern _rt
#endif

/* @summary Define the value indicating an unused device handle.
 */
#ifndef CORE_INPUT_DEVICE_HANDLE_NONE
#define CORE_INPUT_DEVICE_HANDLE_NONE     INVALID_HANDLE_VALUE
#endif

/* @summary Define the maximum number of input devices of each type.
 */
#ifndef CORE_MAX_INPUT_DEVICES
#define CORE_MAX_INPUT_DEVICES            4
#endif

/* @summary Define the maximum number of keys that can be reported as down, pressed or released in a single update.
 */
#ifndef CORE_INPUT_MAX_KEYS
#define CORE_INPUT_MAX_KEYS               8
#endif

/* @summary Define the maximum number of buttons that can be reported as down, pressed or released in a single update.
 */
#ifndef CORE_INPUT_MAX_BUTTONS
#define CORE_INPUT_MAX_BUTTONS            8
#endif

/* @summary Define a bitvector used to poll all possible gamepad ports (all bits set.)
 */
#ifndef CORE_INPUT_ALL_GAMEPAD_PORTS
#define CORE_INPUT_ALL_GAMEPAD_PORTS      ~((uint32_t)(0))
#endif

/* @summary Define the value indicating that an input packet was dropped because too many devices of the specified type are attached.
 */
#ifndef CORE_INPUT_DEVICE_TOO_MANY
#define CORE_INPUT_DEVICE_TOO_MANY        ~((uint32_t)(0))
#endif

/* @summary Define the value indicating that a device was not found in the specified device list.
 */
#ifndef CORE_INPUT_DEVICE_NOT_FOUND
#define CORE_INPUT_DEVICE_NOT_FOUND       ~((uint32_t)(0))
#endif

/* @summary Retrieve the alignment of a particular type, in bytes.
 * @param _type A typename, such as int, specifying the type whose alignment is to be retrieved.
 */
#ifndef CORE_AlignOf
#define CORE_AlignOf(_type)                                                    \
    __alignof(_type)
#endif

/* @summary Align a non-zero size up to the nearest even multiple of a given power-of-two.
 * @param _quantity is the size value to align up.
 * @param _alignment is the desired power-of-two alignment.
 t wi*/
#ifndef CORE_AlignUp
#define CORE_AlignUp(_quantity, _alignment)                                    \
    (((_quantity) + ((_alignment)-1)) & ~((_alignment)-1))
#endif

/* @summary For a given address, return the address aligned for a particular type.
 * @param _address The unaligned address.
 * @param _type A typename, such as int, specifying the type whose alignment is to be retrieved.
 */
#ifndef CORE_AlignFor
#define CORE_AlignFor(_address, _type)                                         \
    ((void*)(((uint8_t*)(_address)) + ((((__alignof(_type))-1)) & ~((__alignof(_type))-1))))
#endif

/* Forward-declare types exported by the library */
struct _CORE_INPUT_EVENTS;
struct _CORE_INPUT_POINTER_EVENTS;
struct _CORE_INPUT_GAMEPAD_EVENTS;
struct _CORE_INPUT_KEYBOARD_EVENTS;
struct _CORE_INPUT_SYSTEM;
struct _CORE_INPUT_SYSTEM_INIT;

/* @summary Define the data used to report events generated by a single XInput gamepad device between two state snapshots.
 */
typedef struct _CORE_INPUT_GAMEPAD_EVENTS {
    float                         LeftTrigger;            /* The left trigger value, in [0, 255]. */
    float                         RightTrigger;           /* The right trigger value, in [0, 255]. */
    float                         LeftStick[2];           /* The left analog stick normalized X and Y. */
    float                         LeftStickMagnitude;     /* The magnitude of the left stick vector. */
    float                         RightStick[2];          /* The right analog stick normalized X and Y. */
    float                         RightStickMagnitude;    /* The magnitude of the right stick vector. */
    uint32_t                      MaxButtonEvents;        /* The maximum number of button events that can be reported. This defines the dimension of the ButtonsDown/ButtonsPressed/ButtonsReleased arrays. */
    uint32_t                      ButtonDownCount;        /* The number of buttons currently in the pressed state. This defines the number of valid entries in the ButtonsDown array. */
    uint32_t                      ButtonPressedCount;     /* The number of buttons just pressed. This defines the number of valid entries in the ButtonsPressed array. */
    uint32_t                      ButtonReleasedCount;    /* The number of buttons just released. This defines the number of valid entries in the ButtonsReleased array. */
    uint16_t                     *ButtonsDown;            /* The XINPUT_GAMEPAD_x identifiers for all buttons currently in the pressed state. */
    uint16_t                     *ButtonsPressed;         /* The XINPUT_GAMEPAD_x identifiers for all buttons that were just transitioned to the pressed state. */
    uint16_t                     *ButtonsReleased;        /* The XINPUT_GAMEPAD_x identifiers for all buttons that were just transitioned to the released state. */
} CORE_INPUT_GAMEPAD_EVENTS;

/* @summary Define the data used to report input events generated by a pointer device (mouse, trackpad, touchscreen, pen, etc.) between two state snapshots.
 */
typedef struct _CORE_INPUT_POINTER_EVENTS
{
    int32_t                       Cursor[2];              /* The absolute cursor position in virtual display space. */
    int32_t                       Mickeys[2];             /* The relative movement of the pointer from the last update, in device-specific units. */
    int32_t                       WheelDelta;             /* The mouse wheel delta from the last update. */
    uint32_t                      MaxButtonEvents;        /* The maximum number of button events that can be reported. This defines the dimension of the ButtonsDown/ButtonsPressed/ButtonsReleased arrays. */
    uint32_t                      ButtonDownCount;        /* The number of buttons currently in the pressed state. This defines the number of valid entries in the ButtonsDown array. */
    uint32_t                      ButtonPressedCount;     /* The number of buttons just pressed. This defines the number of valid entries in the ButtonsPressed array. */
    uint32_t                      ButtonReleasedCount;    /* The number of buttons just released. This defines the number of valid entries in the ButtonsReleased array. */
    uint16_t                     *ButtonsDown;            /* The MK_nBUTTON identifiers for all buttons currently in the pressed state. */
    uint16_t                     *ButtonsPressed;         /* The MK_nBUTTON identifiers for all buttons that were just transitioned to the pressed state. */
    uint16_t                     *ButtonsReleased;        /* The MK_nBUTTON identifiers for all buttons that were just transitioned to the released state. */
} CORE_INPUT_POINTER_EVENTS;

/* @summary Define the data used to report keyboard events generated by a keyboard device between two state snapshots.
 */
typedef struct _CORE_INPUT_KEYBOARD_EVENTS {
    uint32_t                      MaxKeyEvents;           /* The maximum number of key events that can be reported. This defines the dimansion of the KeysDown/KeysPressed/KeysReleased arrays. */
    uint32_t                      KeyDownCount;           /* The number of keys currently in the pressed state. This defines the number of valid entries in the KeysDown array. */
    uint32_t                      KeyPressedCount;        /* The number of keys just pressed. This defines the number of valid entries in the KeysPressed array. */
    uint32_t                      KeyReleasedCount;       /* The number of keys just released. This defines the number of valid entries in the KeysReleased array. */
    uint8_t                      *KeysDown;               /* The VK_x virtual key code for all keys currently in the pressed state. */
    uint8_t                      *KeysPressed;            /* The VK_x virtual key code for all keys that were just transitioned to the pressed state. */
    uint8_t                      *KeysReleased;           /* The VK_x virtual key code for all keys that were just transitioned to the released state. */
} CORE_INPUT_KEYBOARD_EVENTS;

/* @summary Define the data associated with a snapshot of input device events representing all input system events that have occurred since the last poll.
 * This structure should be treated as read-only by the application.
 */
typedef struct _CORE_INPUT_EVENTS {
    struct _CORE_INPUT_SYSTEM    *InputSystem;            /* The _CORE_INPUT_SYSTEM that owns the input event buffer. */
    struct _CORE_INPUT_EVENTS    *NextEvents;             /* A pointer to the next item in the queue. User code always sees this value as NULL. */
    uint64_t                      StartTime;              /* The timestamp, in nanoseconds, at which the input event interval began. */
    uint64_t                      CaptureTime;            /* The timestamp, in nanoseconds, at which the input events were retrieved by the application. */
    uint32_t                      MaxGamepadDevices;      /* The maximum number of gamepad devices that can be attached to the system. This value defines the dimensions of the GamepadAttachList/GamepadRemoveList/GamepadDeviceIds/GamepadDeviceEvents arrays. */
    uint32_t                      GamepadAttachCount;     /* The number of gamepad devices that were attached to the system since the last poll. This value defines the number of valid entries in the GamepadAttachList array. */
    uint32_t                      GamepadRemoveCount;     /* The number of gamepad devices that were detached from the system since the last poll. This value defines the number of valid entries in the GamepadRemoveList array. */
    uint32_t                      GamepadDeviceCount;     /* The number of gamepad devices that are currently attached to the system. This value defines the number of valid entries in the GamepadDeviceIds and GamepadDeviceEvents arrays. */
    DWORD                        *GamepadDeviceIds;       /* An array of GamepadDeviceCount entries specifying the port numbers to which active gamepads are attached. */
    CORE_INPUT_GAMEPAD_EVENTS    *GamepadDeviceEvents;    /* An array of GamepadDeviceCount entries specifying the input events that have occurred for each attached gamepad device. */
    DWORD                        *GamepadAttachList;      /* An array of GamepadAttachCount entries specifying the port IDs to which gamepad devices were attached since the last poll. */
    DWORD                        *GamepadRemoveList;      /* An array of GamepadRemoveCount entries specifying the port IDs from which gamepad devices were removed since the last poll.*/
    uint32_t                      MaxPointerDevices;      /* The maximum number of pointer devices that can be attached to the system. This value defines the dimensions of the PointerAttachList/PointerRemoveList/PointerDeviceIds/PointerDeviceEvents arrays. */
    uint32_t                      PointerAttachCount;     /* The number of pointer devices that were attached to the system since the last poll. This value defines the number of valid entries in the PointerAttachList array. */
    uint32_t                      PointerRemoveCount;     /* The number of pointer devices that were detached from the system since the last poll. This value defines the number of valid entries in the PointerRemoveList array. */
    uint32_t                      PointerDeviceCount;     /* The number of pointer devices that are currently attached to the system. This value defines the number of valid entries in the PointerDeviceIds and PointerDeviceEvents arrays. */
    HANDLE                       *PointerDeviceIds;       /* An array of PointerDeviceCount handles specifying unique identifiers for each pointer device attached to the system. */
    CORE_INPUT_POINTER_EVENTS    *PointerDeviceEvents;    /* An array of PointerDeviceCount entries specifying the input events that have occurred since the last poll for each pointer device. */
    HANDLE                       *PointerAttachList;      /* An array of PointerAttachCount entries specifying the device identifiers for each pointer device attached to the system since the last poll. */
    HANDLE                       *PointerRemoveList;      /* An array of PointerRemoveCount entries specifying the device identifiers for each pointer device detached from the system since the last poll. */
    uint32_t                      MaxKeyboardDevices;     /* The maximum number of keyboard devices that can be attached to the system. This value defines the dimensions of the KeyboardAttachList/KeyboardRemoveList/KeyboardDeviceIds/KeyboardDeviceEvents arrays. */
    uint32_t                      KeyboardAttachCount;    /* The number of keyboard devices that were attached to the system since the last poll. This value defines the number of valid entries in the KeyboardAttachList array. */
    uint32_t                      KeyboardRemoveCount;    /* The number of keyboard devices that were removed from the system since the last poll. This value defines the number of valid entries in the KeyboardRemoveList array. */
    uint32_t                      KeyboardDeviceCount;    /* The number of keyboard devices that are currently attached to the system. This value defines the number of valid entires in the KeyboardDeviceIds and KeyboardDeviceEvents arrays. */
    HANDLE                       *KeyboardDeviceIds;      /* An array of KeyboardDeviceCount entries specifying unique device identifiers for each keyboard device attached to the system. */
    CORE_INPUT_KEYBOARD_EVENTS   *KeyboardDeviceEvents;   /* An array of KeyboardDeviceCount entries specifying the input events that have occurred since the last poll for each keyboard device. */
    HANDLE                       *KeyboardAttachList;     /* An array of KeyboardAttachCount entries specifying the device identifier for each keyboard device attached to the system since the last poll. */
    HANDLE                       *KeyboardRemoveList;     /* An array of KeyboardRemoveCount entries specifying the device identifier for each keyboard device removed from the system since the last poll. */
} CORE_INPUT_EVENTS;

/* @summary Define the data used to configure the behavior of the input system.
 */
typedef struct _CORE_INPUT_SYSTEM_INIT {
    uint32_t                      MaxPointerDevices;      /* The maximum number of supported pointer devices attached to the system at any one time. */
    uint32_t                      MaxGamepadDevices;      /* The maximum number of supported gamepad devices attached to the system at any one time. */
    uint32_t                      MaxKeyboardDevices;     /* The maximum number of supported keyboard devices attached to the system at any one time. */
    uint32_t                      MaxEventsPerGamepad;    /* The maximum number of button events that should be reported per gamepad device. */
    uint32_t                      MaxEventsPerPointer;    /* The maximum number of button events that should be reported per pointer device. */
    uint32_t                      MaxEventsPerKeyboard;   /* The maximum number of key events that should be reported per keyboard device. */
    uint32_t                      MaxInputEventsInFlight; /* The maximum number of _CORE_INPUT_EVENTS structures expected to be in use at any one time. */
} CORE_INPUT_SYSTEM_INIT;

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

CORE_API(size_t)
CORE_QueryInputSystemMemorySize
(
    CORE_INPUT_SYSTEM_INIT *init
);

CORE_API(int)
CORE_CreateInputSystem
(
    struct _CORE_INPUT_SYSTEM **input_system,
    CORE_INPUT_SYSTEM_INIT             *init
);

CORE_API(void)
CORE_ResetInputSystem
(
    struct _CORE_INPUT_SYSTEM *input_system
);

CORE_API(void)
CORE_PushRawInputPacket
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    RAWINPUT                  *input_packet
);

CORE_API(void)
CORE_PushRawInputDeviceChange
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    WPARAM                           wparam, 
    LPARAM                           lparam
);

CORE_API(void)
CORE_SimulateKeyPress
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    HANDLE                           device, 
    UINT                             vkcode
);

CORE_API(void)
CORE_SimulateKeyRelease
(
    struct _CORE_INPUT_SYSTEM *input_system, 
    HANDLE                           device, 
    UINT                             vkcode
);

CORE_API(struct _CORE_INPUT_EVENTS*)
CORE_ConsumeInputEvents
(
    struct _CORE_INPUT_SYSTEM *input_system
);

#ifdef __cplusplus
}; /* extern "C" */
#endif /* __cplusplus */

#endif /* __CORE_INPUT_H__ */

#ifdef CORE_INPUT_IMPLEMENTATION

/* @summary For a given type, calculate the maximum number of bytes that will need to be allocated for an instance of that type, accounting for the padding required for proper alignment.
 * @param _type A typename, such as int, specifying the type whose allocation size is being queried.
 */
#ifndef CORE__InputAllocationSizeType
#define CORE__InputAllocationSizeType(_type)                                   \
    ((sizeof(_type)) + (__alignof(_type)-1))
#endif

/* @summary For a given type, calculate the maximum number of bytes that will need to be allocated for an array of instances of that type, accounting for the padding required for proper alignment.
 * @param _type A typename, such as int, specifying the type whose allocation size is being queried.
 * @param _count The number of elements in the array.
 */
#ifndef CORE__InputAllocationSizeArray
#define CORE__InputAllocationSizeArray(_type, _count)                          \
    ((sizeof(_type) * (_count)) + (__alignof(_type)-1))
#endif

/* @summary Allocate host memory with the correct size and alignment for an instance of a given type from a memory arena.
 * @param _arena The CORE__INPUT_ARENA from which the allocation is being made.
 * @param _type A typename, such as int, specifying the type being allocated.
 * @return A pointer to the start of the allocated memory block, or NULL.
 */
#ifndef CORE__InputMemoryArenaAllocateType
#define CORE__InputMemoryArenaAllocateType(_arena, _type)                      \
    ((_type*) CORE__InputMemoryArenaAllocateHost((_arena), sizeof(_type), __alignof(_type)))
#endif

/* @summary Allocate memory with the correct size and alignment for an array of instance of a given type from a memory arena.
 * @param _arena The CORE__INPUT_ARENA from which the allocation is being made.
 * @param _type A typename, such as int, specifying the type being allocated.
 * @param _count The number of elements in the array.
 * @return A pointer to the start of the allocated memory block, or NULL.
 */
#ifndef CORE__InputMemoryArenaAllocateArray
#define CORE__InputMemoryArenaAllocateArray(_arena, _type, _count)             \
    ((_type*) CORE__InputMemoryArenaAllocateHost((_arena), sizeof(_type) * (_count), __alignof(_type)))
#endif

/* @summary Resolve an entry point from a DLL at runtime. If the entry point is not available, set the function pointer to the stub implementation.
 * Some naming conventions are necessary for these macros to work. Given function name _name = SomeFunction:
 * The function pointer typedef should be: SomeFunction_Func
 * The dispatch table field should be    : SomeFunction
 * The stub function name should be      : CORE__SomeFunction_Stub
 * The resolve call should be            : CORE__InputResolveRuntimeFunction(dispatch_table, dll_instance, SomeFunction)
 * @param _disp A pointer to the structure representing the dispatch table.
 * @param _dll The HMODULE of the DLL returned by LoadLibrary.
 * @param _func_name The name of the function to resolve.
 */
#ifndef CORE__InputResolveRuntimeFunction
#define CORE__InputResolveRuntimeFunction(_disp, _dll, _func_name)             \
    do {                                                                       \
        _disp->_func_name=(_func_name##_Func)GetProcAddress(_dll,#_func_name); \
        if (_disp->_func_name == NULL) {                                       \
            _disp->_func_name  = CORE__##_func_name##_Stub;                    \
        }                                                                      \
    __pragma(warning(push));                                                   \
    __pragma(warning(disable:4127));                                           \
    } while (0);                                                               \
    __pragma(warning(pop))
#endif

/* @summary Implement a conditional check to determine whether a runtime function was resolved to its stub implementation.
 * @param _disp A pointer to the structure representing the dispatch table.
 * @param _func_name The name of the runtime function.
 */
#ifndef CORE__InputIsRuntimeFunctionMissing
#define CORE__InputIsRuntimeFunctionMissing(_disp, _func_name)                 \
    _disp->_func_name == CORE__##_func_name##_Stub
#endif

/* @summary Define the data associated with an internal memory arena allocator.
 */
typedef struct _CORE__INPUT_ARENA {
    uint8_t                      *BaseAddress;            /* The base address of the memory range. */
    size_t                        MemorySize;             /* The size of the memory block, in bytes. */
    size_t                        NextOffset;             /* The offset of the next available address. */
} CORE__INPUT_ARENA;

/* @summary Define the state data associated with a single XInput gamepad device.
 */
typedef struct _CORE__INPUT_GAMEPAD_STATE {
    uint32_t                      LTrigger;               /* The left trigger value, in [0, 255]. */
    uint32_t                      RTrigger;               /* The right trigger value, in [0, 255]. */
    uint32_t                      Buttons;                /* A bit vector storing up to 32 button states, where a set bit indicates that the button is down. */
    float                         LStick[4];              /* The left analog stick X, Y, magnitude and normalized magnitude. */
    float                         RStick[4];              /* The right analog stick X, Y, magnitude and normalized magnitude. */
} CORE__INPUT_GAMEPAD_STATE;

/* @summary Define the state data associated with a single RawInput pointer device.
 */
typedef struct _CORE__INPUT_POINTER_STATE {
    int32_t                       Pointer[2];             /* The absolute X and Y coordinates of the pointer, in virtual display space. */
    int32_t                       Relative[3];            /* The high definition relative X, Y and Z (wheel) values. The X and Y are specified in mickeys. */ 
    uint32_t                      Buttons;                /* A bit vector storing up to 32 button states, where a set bit indicates that the button is down. */
    uint32_t                      Flags;                  /* Bitflags indicating that postprocessing needs to be performed. */
} CORE__INPUT_POINTER_STATE;

/* @summary Define the state data associated with a single RawInput keyboard device.
 */
typedef struct _CORE__INPUT_KEYBOARD_STATE {
    uint32_t                      KeyState[8];            /* A bitvector (256 bits) mapping scan code to key state, where a set bit indicates that the key is down. */
} CORE__INPUT_KEYBOARD_STATE;

/* @summary Define the data associated with a list of input devices of a particular type.
 */
typedef struct _CORE__INPUT_DEVICE_LIST {
    uint32_t                      MaxDevices;             /* The maximum number of device records that can be stored in the list. This value defines the dimension of the DeviceHandle and DeviceState arrays. */
    uint32_t                      DeviceCount;            /* The number of valid device records in the list. This value defines the number of valid values in the DeviceHandle and DeviceState arrays. */
    HANDLE                       *DeviceHandle;           /* An array of MaxDevices device handles, of which DeviceCount are valid, specifying unique identifiers for each input device in the list. */
    void                         *DeviceState;            /* An array of MaxDevices structures, of which DeviceCount are valid. The structure type is one of _CORE__INPUT_GAMEPAD_STATE, _CORE__INPUT_POINTER_STATE or _CORE__INPUT_KEYBOARD_STATE. All instances have the same type. */
} CORE__INPUT_DEVICE_LIST;

/* @summary Define the data associated with a RawInput device membership set computed from two device list snapshots.
 */
typedef struct _CORE__INPUT_DEVICE_SET {
    uint32_t                      MaxDevices;             /* The maximum number of device records in the set. This value defines the dimension of the DeviceIds/Membership/PrevIndex/CurrIndex arrays. */
    uint32_t                      DeviceCount;            /* The number of valid device records in the set. This value defines the number of valid entries in the DeviceIds, Membership, PrevIndex and CurrIndex arrays. */
    HANDLE                       *DeviceIds;              /* An array of MaxDevices device handles, of which DeviceCount are valid, uniquely identifying the devices in the set. */
    uint32_t                     *Membership;             /* An array of MaxDevices _CORE__INPUT_DEVICE_SET_MEMBERSHIP bit flags, of which DeviceCount are valid, specifying the membership for each device in the set. */
    uint8_t                      *PrevIndex;              /* An array of MaxDevices index values, of which DeviceCount are valid, specifying the index of the device in the previous device list. */
    uint8_t                      *CurrIndex;              /* An array of MaxDevices index values, of which DeviceCount are valid, specifying the index of the device in the current device list. */
} CORE__INPUT_DEVICE_SET;

/* @summary Define the function pointer types for the entry points loaded from the XInput module on the host system.
 * See XInput.h (distributed with the Windows SDK) for details.
 */
typedef void  (WINAPI *XInputEnable_Func               )(BOOL);
typedef DWORD (WINAPI *XInputGetState_Func             )(DWORD, struct _XINPUT_STATE*);
typedef DWORD (WINAPI *XInputSetState_Func             )(DWORD, struct _XINPUT_VIBRATION*);
typedef DWORD (WINAPI *XInputGetKeystroke_Func         )(DWORD, DWORD, struct _XINPUT_KEYSTROKE*);
typedef DWORD (WINAPI *XInputGetCapabilities_Func      )(DWORD, DWORD, struct _XINPUT_CAPABILITIES*);
typedef DWORD (WINAPI *XInputGetBatteryInformation_Func)(DWORD, BYTE, struct _XINPUT_BATTERY_INFORMATION*);
typedef DWORD (WINAPI *XInputGetAudioDeviceIds_Func    )(DWORD, LPWSTR, UINT*, LPWSTR, UINT*);

/* @summary Define the table of function pointers to the dynamically-loaded XInput APIs.
 */
typedef struct _CORE__INPUT_XINPUT_DISPATCH {
    HMODULE                          XInputModule;                /* The module handle of the loaded XInput component. */
    XInputEnable_Func                XInputEnable;                /* The pointer to the XInputEnable function. */
    XInputGetState_Func              XInputGetState;              /* The pointer to the XInputGetState function. */
    XInputSetState_Func              XInputSetState;              /* The pointer to the XInputSetState function. */
    XInputGetKeystroke_Func          XInputGetKeystroke;          /* The pointer to the XInputGetKeystroke function. */
    XInputGetCapabilities_Func       XInputGetCapabilities;       /* The pointer to the XInputGetCapabilities function. */
    XInputGetBatteryInformation_Func XInputGetBatteryInformation; /* The pointer to the XInputGetBatteryInformation function. */
    XInputGetAudioDeviceIds_Func     XInputGetAudioDeviceIds;     /* The pointer to the XInputGetAudioDeviceIds function. */
} CORE__INPUT_XINPUT_DISPATCH;

typedef struct _CORE_INPUT_SYSTEM {
    CORE__INPUT_XINPUT_DISPATCH   XInput;                 /* */
} CORE__INPUT_SYSTEM;

typedef enum _CORE__INPUT_DEVICE_SET_MEMBERSHIP {
    CORE__INPUT_DEVICE_SET_MEMBERSHIP_NONE = (0UL << 0),  /* The device is not present in the previous or the current list. */
    CORE__INPUT_DEVICE_SET_MEMBERSHIP_PREV = (1UL << 0),  /* The device is present in the previous device list. */
    CORE__INPUT_DEVICE_SET_MEMBERSHIP_CURR = (1UL << 1),  /* The device is present in the current device list. */
} CORE__INPUT_DEVICE_SET_MEMBERSHIP;

/* @summary Initialize a memory arena allocator around an externally-managed memory block.
 * @param arena The memory arena allocator to initialize.
 * @param memory A pointer to the start of the memory block to sub-allocate from.
 * @param memory_size The size of the memory block, in bytes.
 */
static void
CORE__InputInitMemoryArena
(
    CORE__INPUT_ARENA *arena, 
    void             *memory,
    size_t       memory_size
)
{
    arena->BaseAddress =(uint8_t*) memory;
    arena->MemorySize  = memory_size;
    arena->NextOffset  = 0;
}

/* @summary Sub-allocate memory from an arena.
 * @param arena The memory arena from which the memory will be allocated.
 * @param size The minimum number of bytes to allocate.
 * @param alignment The required alignment of the returned address, in bytes. This value must be zero, or a power-of-two.
 * @return A pointer to the start of a memory block of at least size bytes, or NULL.
 */
static void*
CORE__InputMemoryArenaAllocateHost
(
    CORE__INPUT_ARENA *arena, 
    size_t              size, 
    size_t         alignment
)
{
    uintptr_t    base_address = (uintptr_t) arena->BaseAddress + arena->NextOffset;
    uintptr_t aligned_address =  CORE_AlignUp(base_address, alignment);
    size_t        align_bytes =  aligned_address - base_address;
    size_t        alloc_bytes =  size + align_bytes;
    size_t         new_offset =  arena->NextOffset + alloc_bytes;
    if (new_offset < arena->MemorySize)
    {   /* the arena can satisfy the allocation */
        arena->NextOffset = new_offset;
        return (void*) aligned_address;
    }
    else
    {   /* the arena cannot satisfy the allocation */
        return NULL;
    }
}

/* @summary Define a stub no-op implementation of the XInputEnable API.
 * @param enable If enable is FALSE XInput will only send neutral data in response to XInputGetState.
 */
static void WINAPI
CORE__XInputEnable_Stub
(
    BOOL enable
)
{
    UNREFERENCED_PARAMETER(enable);
}

/* @summary Define a stub no-op implementation of the XInputGetState API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param state Pointer to an XINPUT_STATE structure that receives the current state of the controller.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetState_Stub
(
    DWORD            user_index, 
    struct _XINPUT_STATE *state
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(state);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputSetState API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param vibration Pointer to an XINPUT_VIBRATION structure containing vibration information to send to the controller.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputSetState_Stub
(
    DWORD                    user_index, 
    struct _XINPUT_VIBRATION *vibration
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(vibration);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetKeystroke API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param reserved This value is reserved for future use and should be set to zero.
 * @param keystroke Pointer to an XINPUT_KEYSTROKE structure that receives an input event.
 * @return ERROR_SUCCESS, ERROR_EMPTY or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetKeystroke_Stub
(
    DWORD                    user_index, 
    DWORD                      reserved, 
    struct _XINPUT_KEYSTROKE *keystroke
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(reserved);
    UNREFERENCED_PARAMETER(keystroke);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetKeystroke API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param flags Input flags that identify the controller type. Either 0 or XINPUT_FLAG_GAMEPAD.
 * @param capabilities Pointer to an XINPUT_CAPABILITIES structure that receives the controller capabilities.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetCapabilities_Stub
(
    DWORD                          user_index, 
    DWORD                               flags, 
    struct _XINPUT_CAPABILITIES *capabilities
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(flags);
    UNREFERENCED_PARAMETER(capabilities);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetBatteryInformation API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param device_type Specifies which device associated with this user index should be queried. Must be BATTERY_DEVTYPE_GAMEPAD or BATTERY_DEVTYPE_HEADSET.
 * @param battery_info Pointer to an XINPUT_BATTERY_INFORMATION that receives battery information.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetBatteryInformation_Stub
(
    DWORD                                 user_index, 
    BYTE                                 device_type, 
    struct _XINPUT_BATTERY_INFORMATION *battery_info
)
{
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(device_type);
    UNREFERENCED_PARAMETER(battery_info);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Define a stub no-op implementation of the XInputGetAudioDeviceIds API.
 * @param user_index The index of the user's controller, in [0, 3].
 * @param render_device_id Windows Core Audio device ID string for render (speakers).
 * @param render_device_chars The size, in wide-chars, of the render device ID string buffer.
 * @param capture_device_id Windows Core Audio device ID string for capture (microphone).
 * @param capture_device_chars The size, in wide-chars, of the capture device ID string buffer.
 * @return ERROR_SUCCESS or ERROR_DEVICE_NOT_CONNECTED.
 */
static DWORD WINAPI
CORE__XInputGetAudioDeviceIds_Stub
(
    DWORD             user_index, 
    LPWSTR      render_device_id, 
    UINT    *render_device_chars, 
    LPWSTR     capture_device_id, 
    UINT   *capture_device_chars
)
{
    if (render_device_chars != NULL) *render_device_chars = 0;
    if (capture_device_chars != NULL) *capture_device_chars = 0;
    UNREFERENCED_PARAMETER(user_index);
    UNREFERENCED_PARAMETER(render_device_id);
    UNREFERENCED_PARAMETER(capture_device_id);
    return ERROR_DEVICE_NOT_CONNECTED;
}

/* @summary Attempt to load the host system XInput implementation into the process address space and resolve the XInput APIs.
 * @param disp The CORE__INPUT_XINPUT_DISPATCH structure representing the XInput API dispatch table to populate.
 * @param missing_entry_points On return, set to non-zero if any API entry points are missing and were resolved to their stub implementation.
 * @return Zero if the XInput module was loaded and XInput APIs were resolved, or -1 if XInput is not available.
 */
static int
CORE__LoadXInput
(
    CORE__INPUT_XINPUT_DISPATCH *disp, 
    int         *missing_entry_points
)
{
    HMODULE xinput = NULL;
    if ((xinput = LoadLibrary(_T("xinput1_4.dll"))) == NULL) /* Windows 8+ */
    {   /* try with XInput 9.1.0, which shipped with Vista */
        if ((xinput = LoadLibrary(_T("xinput9_1_0.dll"))) == NULL)
        {   /* try for XInput 1.3, which shipped with the June 2010 DirectX SDK */
            if ((xinput = LoadLibrary(_T("xinput1_3.dll"))) == NULL)
            {   /* no XInput is available */
                disp->XInputModule                = NULL;
                disp->XInputEnable                = CORE__XInputEnable_Stub;
                disp->XInputGetState              = CORE__XInputGetState_Stub;
                disp->XInputSetState              = CORE__XInputSetState_Stub;
                disp->XInputGetKeystroke          = CORE__XInputGetKeystroke_Stub;
                disp->XInputGetCapabilities       = CORE__XInputGetCapabilities_Stub;
                disp->XInputGetBatteryInformation = CORE__XInputGetBatteryInformation_Stub;
                disp->XInputGetAudioDeviceIds     = CORE__XInputGetAudioDeviceIds_Stub;
               *missing_entry_points = 1;
                return -1;
            }
        }
    }

    /* some version of XInput is available, resolve the function entry points */
    disp->XInputModule = xinput;
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputEnable);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetState);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputSetState);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetKeystroke);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetCapabilities);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetBatteryInformation);
    CORE__InputResolveRuntimeFunction(disp, xinput, XInputGetAudioDeviceIds);
   *missing_entry_points = 0;
    
   /* determine whether any API entry points could not be resolved */
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputEnable               )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetState             )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputSetState             )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetKeystroke         )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetCapabilities      )) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetBatteryInformation)) *missing_entry_points = 1;
    if (CORE__InputIsRuntimeFunctionMissing(disp, XInputGetAudioDeviceIds    )) *missing_entry_points = 1;
    return 0;
}

static uint32_t
CORE__FindInputDeviceForHandle
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    HANDLE                 device_handle
)
{
    uint32_t i, n;
    HANDLE *devid = device_list->DeviceHandle;
    for (i = 0, n = device_list->DeviceCount; i < n; ++i)
    {
        if (devid[i] == device_handle)
            return i;
    }
    return CORE_INPUT_DEVICE_NOT_FOUND;
}

#ifndef CORE__InputDeviceListState
#define CORE__InputDeviceListState(_list, _index , _state_size)                \
    (((uint8_t*)(_list)->DeviceState) + ((_index)*(_state_size)))
#endif

#ifndef CORE__GamepadDeviceListState
#define CORE__GamepadDeviceListState(_list, _index)                            \
    (CORE__INPUT_GAMEPAD_STATE*) CORE__InputDeviceListState((_list), (_index), sizeof(CORE__INPUT_GAMEPAD_STATE))
#endif

#ifndef CORE__PointerDeviceListState
#define CORE__PointerDeviceListState(_list, _index)                            \
    (CORE__INPUT_POINTER_STATE*) CORE__InputDeviceListState((_list), (_index), sizeof(CORE__INPUT_POINTER_STATE))
#endif

#ifndef CORE__KeyboardDeviceListState
#define CORE__KeyboardDeviceListState(_list, _index)                           \
    (CORE__INPUT_KEYBOARD_STATE*)CORE__InputDeviceListState((_list), (_index), sizeof(CORE__INPUT_KEYBOARD_STATE))
#endif

static uint32_t
CORE__HandleInputDeviceAttach
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    HANDLE                 device_handle, 
    void                  *default_state, 
    size_t                    state_size
)
{
    uint32_t i, n;
    HANDLE *devid = device_list->DeviceHandle;
    for (i = 0, n = device_list->DeviceCount; i < n; ++i)
    {
        if (devid[i] == device_handle)
        {   /* the device is already present in the list - don't modify its state */
            return i;
        }
    }
    /* add the device to the end of the device list */
    if (device_list->DeviceCount == device_list->MaxDevices)
    {   /* there are too many devices of the specified type attached */
        return CORE_INPUT_DEVICE_TOO_MANY;
    }
    CopyMemory(CORE__InputDeviceListState(device_list, i, state_size), default_state, state_size);
    device_list->DeviceHandle[i] = device_handle;
    device_list->DeviceCount++;
    return i;
}

#if 0
static int
CORE__HandleInputDeviceRemove
(
    CORE__INPUT_DEVICE_LIST *device_list, 
    HANDLE                 device_handle
)
{
}
#endif

#endif /* CORE_INPUT_IMPLEMENTATION */

